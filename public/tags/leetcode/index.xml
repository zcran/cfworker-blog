<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on Paperubit的博客</title>
    <link>http://example.org/tags/leetcode/</link>
    <description>Recent content in leetcode on Paperubit的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 19 Dec 2023 15:49:31 +0800</lastBuildDate><atom:link href="http://example.org/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 快速选择1</title>
      <link>http://example.org/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A91/</link>
      <pubDate>Tue, 19 Dec 2023 15:49:31 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A91/</guid>
      <description>摆动排序 II 给你一个整数数组 nums，将它重新排列成 nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]&amp;hellip; 的顺序。
你可以假设所有输入数组都可以得到满足题目要求的结果。
impl Solution { pub fn wiggle_sort(nums: &amp;amp;mut Vec&amp;lt;i32&amp;gt;) { let mut nums_copy = nums.clone(); nums_copy.sort(); let n = nums.len(); let (mut p, mut q) = ((n - 1) / 2, n - 1); for i in 0..n { if (i &amp;amp; 1) == 1 { nums[i] = nums_copy[q]; q -= 1; } else { nums[i] = nums_copy[p]; p -= 1; }; } } } </description>
    </item>
    
    <item>
      <title>Leetcode 快速选择2</title>
      <link>http://example.org/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A92/</link>
      <pubDate>Tue, 19 Dec 2023 15:49:31 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A92/</guid>
      <description>数组中的第K个最大元素 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
use std::collections::BinaryHeap; impl Solution { pub fn find_kth_largest(nums: Vec&amp;lt;i32&amp;gt;, k: i32) -&amp;gt; i32 { let mut h = BinaryHeap::from(nums.iter().map(|&amp;amp;i| -i).take(k as usize).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;()); for i in k as usize..nums.len() { h.push(-nums[i]); h.pop(); } -h.peek().unwrap() } } </description>
    </item>
    
    <item>
      <title>Leetcode 快速选择3</title>
      <link>http://example.org/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A93/</link>
      <pubDate>Tue, 19 Dec 2023 15:49:31 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A93/</guid>
      <description>找出第 K 大的异或坐标值 给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。
矩阵中坐标 (a, b) 的 值 可由对所有满足 0 &amp;lt;= i &amp;lt;= a &amp;lt; m 且 0 &amp;lt;= j &amp;lt;= b &amp;lt; n 的元素 matrix[i][j]（下标从 0 开始计数）执行异或运算得到。
请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。
impl Solution { pub fn kth_largest_value(mut matrix: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;, k: i32) -&amp;gt; i32 { for row in 0..matrix.len() { let mut sum = 0; for col in 0.</description>
    </item>
    
    <item>
      <title>Leetcode 快速选择4</title>
      <link>http://example.org/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A94/</link>
      <pubDate>Tue, 19 Dec 2023 15:49:31 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A94/</guid>
      <description>找出数组中的第 K 大整数 给你一个字符串数组 nums 和一个整数 k 。nums 中的每个字符串都表示一个不含前导零的整数。
返回 nums 中表示第 k 大整数的字符串。
注意：重复的数字在统计时会视为不同元素考虑。例如，如果 nums 是 [&amp;ldquo;1&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;2&amp;rdquo;]，那么 &amp;ldquo;2&amp;rdquo; 是最大的整数，&amp;ldquo;2&amp;rdquo; 是第二大的整数，&amp;ldquo;1&amp;rdquo; 是第三大的整数。
impl Solution { pub fn kth_largest_number(mut nums: Vec&amp;lt;String&amp;gt;, k: i32) -&amp;gt; String { // 自定义比较函数，在 a 对应的整数较大时返回 true，反之返回 false nums.sort_by(|a, b| { // 首先比较字符串长度 if a.len() &amp;gt; b.len() { return std::cmp::Ordering::Greater; } else if a.len() &amp;lt; b.len() { return std::cmp::Ordering::Less; } else { // 长度相等时比较字符串字典序大小 a.cmp(&amp;amp;b) } }); nums[nums.</description>
    </item>
    
    <item>
      <title>Leetcode 快速选择5</title>
      <link>http://example.org/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A95/</link>
      <pubDate>Tue, 19 Dec 2023 15:49:31 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A95/</guid>
      <description>最接近原点的 K 个点 给定一个数组 points ，其中 points[i] = [x⌄i, y⌄i] 表示 X-Y 平面上的一个点，并且是一个整数 k ，返回离原点 (0,0) 最近的 k 个点。
这里，平面上两点之间的距离是 欧几里德距离（ √(x⌄1 - x⌄2)2 + (y⌄1 - y⌄2)2 ）。
你可以按 任何顺序 返回答案。除了点坐标的顺序之外，答案 确保 是 唯一 的。
impl Solution { pub fn k_closest(points: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;, k: i32) -&amp;gt; Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; { let mut ans = points; ans.sort_unstable_by_key(|a| a[0] * a[0] + a[1] * a[1]); ans.truncate(k as usize); // 保留第一个 k 元素，然后丢弃其余的元素 ans } } </description>
    </item>
    
    <item>
      <title>Leetcode 快速选择6</title>
      <link>http://example.org/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A96/</link>
      <pubDate>Tue, 19 Dec 2023 15:49:31 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A96/</guid>
      <description>最小K个数 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
示例：
输入： arr = [1,3,5,7,2,4,6,8], k = 4 输出： [1,2,3,4] 提示：
0 &amp;lt;= len(arr) &amp;lt;= 100000 0 &amp;lt;= k &amp;lt;= min(100000, len(arr))
impl Solution { pub fn get_least_numbers(arr: Vec&amp;lt;i32&amp;gt;, k: i32) -&amp;gt; Vec&amp;lt;i32&amp;gt; { let mut arr = arr; arr.sort(); arr[..k as usize].iter().cloned().collect() } } </description>
    </item>
    
    <item>
      <title>Leetcode 迭代器1</title>
      <link>http://example.org/posts/leetcode-%E8%BF%AD%E4%BB%A3%E5%99%A81/</link>
      <pubDate>Tue, 19 Dec 2023 15:49:00 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E8%BF%AD%E4%BB%A3%E5%99%A81/</guid>
      <description>二叉搜索树迭代器 实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器： BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。 boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。 int next()将指针向右移动，然后返回指针处的数字。 注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。
你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。
struct BSTIterator { stack: Vec&amp;lt;Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;&amp;gt;, } use std::cell::RefCell; use std::rc::Rc; impl BSTIterator { fn new(root: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; Self { BSTIterator { stack: vec![root] } } fn next(&amp;amp;mut self) -&amp;gt; i32 { let mut node = self.</description>
    </item>
    
    <item>
      <title>Leetcode 迭代器2</title>
      <link>http://example.org/posts/leetcode-%E8%BF%AD%E4%BB%A3%E5%99%A82/</link>
      <pubDate>Tue, 19 Dec 2023 15:49:00 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E8%BF%AD%E4%BB%A3%E5%99%A82/</guid>
      <description>扁平化嵌套列表迭代器 给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。
实现扁平迭代器类 NestedIterator ：
NestedIterator(List nestedList) 用嵌套列表 nestedList 初始化迭代器。 int next() 返回嵌套列表的下一个整数。 boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。 你的代码将会用下述伪代码检测：
initialize iterator with nestedList res = [] while iterator.hasNext() append iterator.next() to the end of res return res 如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。
struct NestedIterator(Vec&amp;lt;i32&amp;gt;); impl NestedIterator { fn new(nestedList: Vec&amp;lt;NestedInteger&amp;gt;) -&amp;gt; Self { let mut v=collect(nestedList); v.reverse(); Self(v) } #[inline(always)] fn next(&amp;amp;mut self) -&amp;gt; i32 { self.0.pop().unwrap() } #[inline(always)] fn has_next(&amp;amp;self) -&amp;gt; bool { self.</description>
    </item>
    
    <item>
      <title>Leetcode 迭代器3</title>
      <link>http://example.org/posts/leetcode-%E8%BF%AD%E4%BB%A3%E5%99%A83/</link>
      <pubDate>Tue, 19 Dec 2023 15:49:00 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E8%BF%AD%E4%BB%A3%E5%99%A83/</guid>
      <description>RLE 迭代器 我们可以使用游程编码(即 RLE )来编码一个整数序列。在偶数长度 encoding ( 从 0 开始 )的游程编码数组中，对于所有偶数 i ，encoding[i] 告诉我们非负整数 encoding[i + 1] 在序列中重复的次数。
例如，序列 arr = [8,8,8,5,5] 可以被编码为 encoding =[3,8,2,5] 。encoding =[3,8,0,9,2,5] 和 encoding =[2,8,1,8,2,5] 也是 arr 有效的 RLE 。 给定一个游程长度的编码数组，设计一个迭代器来遍历它。
实现 RLEIterator 类:
RLEIterator(int[] encoded) 用编码后的数组初始化对象。 int next(int n) 以这种方式耗尽后 n 个元素并返回最后一个耗尽的元素。如果没有剩余的元素要耗尽，则返回 -1 。
struct RLEIterator { iterator: std::vec::IntoIter&amp;lt;i32&amp;gt;, remain: (i32, i32), } /** * `&amp;amp;self` means the method takes an immutable reference. * If you need a mutable reference, change it to `&amp;amp;mut self` instead.</description>
    </item>
    
    <item>
      <title>Leetcode 迭代器4</title>
      <link>http://example.org/posts/leetcode-%E8%BF%AD%E4%BB%A3%E5%99%A84/</link>
      <pubDate>Tue, 19 Dec 2023 15:49:00 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E8%BF%AD%E4%BB%A3%E5%99%A84/</guid>
      <description>字母组合迭代器 请你设计一个迭代器类 CombinationIterator ，包括以下内容：
CombinationIterator(string characters, int combinationLength) 一个构造函数，输入参数包括：用一个 有序且字符唯一 的字符串 characters（该字符串只包含小写英文字母）和一个数字 combinationLength 。 函数 next() ，按 字典序 返回长度为 combinationLength 的下一个字母组合。 函数 hasNext() ，只有存在长度为 combinationLength 的下一个字母组合时，才返回 true
struct CombinationIterator { s: Vec&amp;lt;u8&amp;gt;, pos: Vec&amp;lt;usize&amp;gt;, has_next: bool, } impl CombinationIterator { fn new(characters: String, len: i32) -&amp;gt; Self { let mut s = characters.into_bytes(); s.sort_unstable(); Self { s, pos: (0..len as usize).collect(), has_next: true, } } fn next(&amp;amp;mut self) -&amp;gt; String { fn dfs(pos: &amp;amp;mut Vec&amp;lt;usize&amp;gt;, cur: usize, len: usize, has_next: &amp;amp;mut bool) -&amp;gt; usize { let i = pos.</description>
    </item>
    
    <item>
      <title>Leetcode 概率与统计4</title>
      <link>http://example.org/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A14/</link>
      <pubDate>Tue, 19 Dec 2023 15:47:55 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A14/</guid>
      <description>新 21 点 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
爱丽丝以 0 分开始，并在她的得分少于 k 分时抽取数字。 抽取时，她从 [1, maxPts] 的范围中随机获得一个整数作为分数进行累计，其中 maxPts 是一个整数。 每次抽取都是独立的，其结果具有相同的概率。
当爱丽丝获得 k 分 或更多分 时，她就停止抽取数字。
爱丽丝的分数不超过 n 的概率是多少？
与实际答案误差不超过 10-5 的答案将被视为正确答案。
示例 1：
输入：n = 10, k = 1, maxPts = 10 输出：1.00000 解释：爱丽丝得到一张牌，然后停止。 示例 2：
输入：n = 6, k = 1, maxPts = 10 输出：0.60000 解释：爱丽丝得到一张牌，然后停止。 在 10 种可能性中的 6 种情况下，她的得分不超过 6 分。 示例 3：
输入：n = 21, k = 17, maxPts = 10 输出：0.</description>
    </item>
    
    <item>
      <title>Leetcode 概率与统计5</title>
      <link>http://example.org/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A15/</link>
      <pubDate>Tue, 19 Dec 2023 15:47:55 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A15/</guid>
      <description>N个骰子的点数 你选择掷出 num 个色子，请返回所有点数总和的概率。
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 num 个骰子所能掷出的点数集合中第 i 小的那个的概率。
impl Solution { pub fn dices_probability(n: i32) -&amp;gt; Vec&amp;lt;f64&amp;gt; { let mut ans = vec![1.0 / 6.0].repeat(6); for i in 2..=n as usize { let mut tmp = vec![0.0; 5 * i + 1]; for j in 0..6 { for k in 0..ans.len() { tmp[k + j] += ans[k] / 6.0; } } ans = tmp; } ans } } </description>
    </item>
    
    <item>
      <title>Leetcode 概率与统计1</title>
      <link>http://example.org/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A11/</link>
      <pubDate>Tue, 19 Dec 2023 15:47:54 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A11/</guid>
      <description>飞机座位分配概率 有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。
剩下的乘客将会：
如果他们自己的座位还空着，就坐到自己的座位上，
当他们自己的座位被占用时，随机选择其他座位 第 n 位乘客坐在自己的座位上的概率是多少？
impl Solution { pub fn nth_person_gets_nth_seat(n: i32) -&amp;gt; f64 { if n &amp;lt;= 2 { return 1.0 / n as f64 } let mut prob = 0.5; for i in 3..=n { prob = (1.0 + (i - 2) as f64 * prob) / i as f64; } prob } } </description>
    </item>
    
    <item>
      <title>Leetcode 概率与统计2</title>
      <link>http://example.org/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A12/</link>
      <pubDate>Tue, 19 Dec 2023 15:47:54 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A12/</guid>
      <description>分汤 有 A 和 B 两种类型 的汤。一开始每种类型的汤有 n 毫升。有四种分配操作：
提供 100ml 的 汤A 和 0ml 的 汤B 。 提供 75ml 的 汤A 和 25ml 的 汤B 。 提供 50ml 的 汤A 和 50ml 的 汤B 。 提供 25ml 的 汤A 和 75ml 的 汤B 。 当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。
注意 不存在先分配 100 ml 汤B 的操作。
需要返回的值： 汤A 先分配完的概率 + 汤A和汤B 同时分配完的概率 / 2。返回值在正确答案 10-5 的范围内将被认为是正确的。
impl Solution { pub fn soup_servings(n: i32) -&amp;gt; f64 { fn recursive(dp: &amp;amp;mut Vec&amp;lt;Vec&amp;lt;f64&amp;gt;&amp;gt;, a: i32, b: i32) -&amp;gt; f64 { if a &amp;lt;= 0 &amp;amp;&amp;amp; b &amp;lt;= 0 { return 0.</description>
    </item>
    
    <item>
      <title>Leetcode 概率与统计3</title>
      <link>http://example.org/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A13/</link>
      <pubDate>Tue, 19 Dec 2023 15:47:54 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A13/</guid>
      <description>期望个数统计 某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。
小 A 和小 B 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中等可能地取一个。现在给定 n 名面试者的能力值 scores，设 X 代表小 A 和小 B 的浏览顺序中出现在同一位置的简历数，求 X 的期望。
提示：离散的非负随机变量的期望计算公式为。在本题中，由于 X 的取值为 0 到 n 之间，期望计算公式可以是。
impl Solution { pub fn expect_number(scores: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { scores.into_iter().collect::&amp;lt;std::collections::HashSet&amp;lt;i32&amp;gt;&amp;gt;().len() as i32 } } </description>
    </item>
    
    <item>
      <title>Leetcode 后缀数组1</title>
      <link>http://example.org/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%841/</link>
      <pubDate>Tue, 19 Dec 2023 15:46:47 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%841/</guid>
      <description>构造字符串的总得分和 你需要从空字符串开始 构造 一个长度为 n 的字符串 s ，构造的过程为每次给当前字符串 前面 添加 一个 字符。构造过程中得到的所有字符串编号为 1 到 n ，其中长度为 i 的字符串编号为 si 。
比方说，s = &amp;ldquo;abaca&amp;rdquo; ，s1 == &amp;ldquo;a&amp;rdquo; ，s2 == &amp;ldquo;ca&amp;rdquo; ，s3 == &amp;ldquo;aca&amp;rdquo; 依次类推。 si 的 得分 为 si 和 sn 的 最长公共前缀 的长度（注意 s == sn ）。
给你最终的字符串 s ，请你返回每一个 si 的 得分之和 。
class Solution { public: long long sumScores(string s) { int n = s.length(); long ans = n; vector&amp;lt;int&amp;gt; z(n); for (int i = 1, l = 0, r = 0; i &amp;lt; n; ++i) { z[i] = max(min(z[i - l], r - i + 1), 0); while (i + z[i] &amp;lt; n &amp;amp;&amp;amp; s[z[i]] == s[i + z[i]]) { l = i; r = i + z[i]; ++z[i]; } ans += z[i]; } return ans; } }; </description>
    </item>
    
    <item>
      <title>Leetcode 后缀数组2</title>
      <link>http://example.org/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%842/</link>
      <pubDate>Tue, 19 Dec 2023 15:46:47 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%842/</guid>
      <description>划分数字的方案数 你写下了若干 正整数 ，并将它们连接成了一个字符串 num 。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 非递减 的且 没有 任何数字有前导 0 。
请你返回有多少种可能的 正整数数组 可以得到字符串 num 。由于答案可能很大，将结果对 10^9 + 7 取余 后返回。
impl Solution { pub fn number_of_combinations(num: String) -&amp;gt; i32 { if num.chars().nth(0) == Some(&amp;#39;0&amp;#39;) {return 0;} let n = num.len(); let mut ord = vec![vec![0;n + 1];n]; for i in 0..n { ord[i][1] = (num.chars().nth(i).unwrap() as u8 - &amp;#39;0&amp;#39; as u8) as usize; } let mut nr_ord = 10; for l in 2.</description>
    </item>
    
    <item>
      <title>Leetcode 后缀数组3</title>
      <link>http://example.org/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%843/</link>
      <pubDate>Tue, 19 Dec 2023 15:46:47 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%843/</guid>
      <description>最长公共子路径 一个国家由 n 个编号为 0 到 n - 1 的城市组成。在这个国家里，每两个 城市之间都有一条道路连接。
总共有 m 个编号为 0 到 m - 1 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 重复 出现，但同一个城市在一条路径中不会连续出现。
给你一个整数 n 和二维数组 paths ，其中 paths[i] 是一个整数数组，表示第 i 个朋友走过的路径，请你返回 每一个 朋友都走过的 最长公共子路径 的长度，如果不存在公共子路径，请你返回 0 。
一个 子路径 指的是一条路径中连续的城市序列。
fn sa_is(s: &amp;amp;[usize], upper: usize) -&amp;gt; Vec&amp;lt;usize&amp;gt; { let n = s.len(); match n { 0 =&amp;gt; return vec![], 1 =&amp;gt; return vec![0], 2 =&amp;gt; return if s[0] &amp;lt; s[1] { vec!</description>
    </item>
    
    <item>
      <title>Leetcode 后缀数组4</title>
      <link>http://example.org/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%844/</link>
      <pubDate>Tue, 19 Dec 2023 15:46:47 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%844/</guid>
      <description>最长重复子串 给你一个字符串 s ，考虑其所有 重复子串 ：即 s 的（连续）子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。
返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 &amp;quot;&amp;quot; 。
impl Solution { // tp已经排好，开始排序第一关键字 fn sort(sa: &amp;amp;mut Vec&amp;lt;usize&amp;gt;, rank: &amp;amp;mut Vec&amp;lt;usize&amp;gt;, tp: &amp;amp;Vec&amp;lt;usize&amp;gt;, n: usize, m: usize) { let mut tax = vec![0; m+1]; // 第一关键字基数排序 rank[1..].iter().for_each(|x| tax[*x] += 1); // 前缀和，为了后面方便计算第几名 for i in 1..=m { tax[i] += tax[i-1]; } tp[1..].iter().rev().for_each(|&amp;amp;key| { // 拿最小的第二关键字对应的后缀key_2，然后通过rank找到他对应的第一关键字所处的level(第一关键字排名) let level = rank[key]; // tax[level]就表示在这里level之下一共有j个数，则后缀(tp[i])排名第j // 此时放的是第一关键字相同，第二关键字最大 // rank其实也是排好的，拿的是前w/2的rank let j = tax[level]; sa[j] = key; tax[level] -= 1; }); } fn init(s: &amp;amp;str, n: usize, m: usize) -&amp;gt; (Vec&amp;lt;usize&amp;gt;, Vec&amp;lt;usize&amp;gt;, Vec&amp;lt;usize&amp;gt;) { // 只有第一关键字直接映射就好 let mut rank = vec!</description>
    </item>
    
    <item>
      <title>Leetcode 桶排序1</title>
      <link>http://example.org/posts/leetcode-%E6%A1%B6%E6%8E%92%E5%BA%8F1/</link>
      <pubDate>Tue, 19 Dec 2023 15:46:22 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%A1%B6%E6%8E%92%E5%BA%8F1/</guid>
      <description>存在重复元素 III 给你一个整数数组 nums 和两个整数 indexDiff 和 valueDiff 。
找出满足下述条件的下标对 (i, j)：
i != j, abs(i - j) &amp;lt;= indexDiff abs(nums[i] - nums[j]) &amp;lt;= valueDiff 如果存在，返回 true ；否则，返回 false 。
impl Solution { pub fn contains_nearby_almost_duplicate( nums: Vec&amp;lt;i32&amp;gt;, index_diff: i32, value_diff: i32, ) -&amp;gt; bool { // NOTE 桶排序的好题，通过将数字划分为若干个区间，来判断是否滑动窗口内是否存在value_diff范围内的数字对 // 桶的大小为value_diff，作为整除的除数因此加一 let value_diff = value_diff as i64 + 1; let mut num_bucket = std::collections::HashMap::new(); for (i, &amp;amp;num) in nums.iter().enumerate() { let key = Self::get_id(num, value_diff); if num_bucket.</description>
    </item>
    
    <item>
      <title>Leetcode 桶排序2</title>
      <link>http://example.org/posts/leetcode-%E6%A1%B6%E6%8E%92%E5%BA%8F2/</link>
      <pubDate>Tue, 19 Dec 2023 15:46:22 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%A1%B6%E6%8E%92%E5%BA%8F2/</guid>
      <description>根据字符出现频率排序 给定一个字符串 s ，根据字符出现的 频率 对其进行 降序排序 。一个字符出现的 频率 是它出现在字符串中的次数。
返回 已排序的字符串 。如果有多个答案，返回其中任何一个。
impl Solution { pub fn frequency_sort(s: String) -&amp;gt; String { let mut bucket = vec![(0,0);256]; for b in s.bytes() { bucket[b as usize].0 += 1; bucket[b as usize].1 = b; } bucket.sort_by(|a, b| b.0.cmp(&amp;amp;a.0)); let mut res = String::new(); for (times, ch) in bucket { for _ in 0..times { res.push(ch as char); } } res } } </description>
    </item>
    
    <item>
      <title>Leetcode 桶排序3</title>
      <link>http://example.org/posts/leetcode-%E6%A1%B6%E6%8E%92%E5%BA%8F3/</link>
      <pubDate>Tue, 19 Dec 2023 15:46:22 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%A1%B6%E6%8E%92%E5%BA%8F3/</guid>
      <description>前K个高频单词 给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。
返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。
use std::collections::{HashMap, BTreeSet}; impl Solution { pub fn top_k_frequent(words: Vec&amp;lt;String&amp;gt;, k: i32) -&amp;gt; Vec&amp;lt;String&amp;gt; { let mut cnt = HashMap::new(); let mut max_freq = 0; for word in words { let entry = cnt.entry(word).or_insert(0); *entry += 1; max_freq = max_freq.max(*entry); } let mut buckets = vec![BTreeSet::new(); max_freq as usize + 1]; for (word, freq) in cnt.iter() { buckets[*freq as usize].</description>
    </item>
    
    <item>
      <title>Leetcode 桶排序4</title>
      <link>http://example.org/posts/leetcode-%E6%A1%B6%E6%8E%92%E5%BA%8F4/</link>
      <pubDate>Tue, 19 Dec 2023 15:46:22 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%A1%B6%E6%8E%92%E5%BA%8F4/</guid>
      <description>前 K 个高频元素 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
class Solution { public: vector&amp;lt;int&amp;gt; topKFrequent(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int,int&amp;gt; mp; vector&amp;lt;int&amp;gt; res; //统计最大的频次，决定开多大的空间 int max_cnt=0; for(auto num:nums) { mp[num]++; max_cnt=max(max_cnt,mp[num]); } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; bucket(max_cnt+1); //计数，桶号为频次，元素为数字 for(auto iter:mp){ bucket[iter.second].push_back(iter.first); } for(int i=bucket.size()-1;i&amp;gt;=0 &amp;amp;&amp;amp; k;i--){ for(auto num:bucket[i]){ if(k--) res.push_back(num); else break; } } return res; } }; use std::{ cmp::Reverse, collections::{BinaryHeap, HashMap}, }; impl Solution { pub fn top_k_frequent(nums: Vec&amp;lt;i32&amp;gt;, k: i32) -&amp;gt; Vec&amp;lt;i32&amp;gt; { let mut map = HashMap::new(); nums.</description>
    </item>
    
    <item>
      <title>Leetcode 计数排序1</title>
      <link>http://example.org/posts/leetcode-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F1/</link>
      <pubDate>Tue, 19 Dec 2023 15:45:23 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F1/</guid>
      <description>高度检查器 学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 非递减 的高度顺序排成一行。
排序后的高度情况用整数数组 expected 表示，其中 expected[i] 是预计排在这一行中第 i 位的学生的高度（下标从 0 开始）。
给你一个整数数组 heights ，表示 当前学生站位 的高度情况。heights[i] 是这一行中第 i 位学生的高度（下标从 0 开始）。
返回满足 heights[i] != expected[i] 的 下标数量 。
impl Solution { pub fn height_checker(heights: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { let mut cnt = vec![0; 101]; heights.iter().for_each(|i| cnt[*i as usize] += 1); for i in 1..101 { cnt[i] += cnt[i - 1]; } let mut ret = 0; for i in 0.</description>
    </item>
    
    <item>
      <title>Leetcode 计数排序2</title>
      <link>http://example.org/posts/leetcode-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F2/</link>
      <pubDate>Tue, 19 Dec 2023 15:45:23 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F2/</guid>
      <description>数组拆分 给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a^1, b^1), (a^2, b^2), &amp;hellip;, (a^n, b^n) ，使得从 1 到 n 的 min(a^i, b^i) 总和最大。
返回该 最大总和 。
impl Solution { pub fn array_pair_sum(nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { let mut nums = nums; nums.sort_unstable(); nums.iter().step_by(2).sum() } } </description>
    </item>
    
    <item>
      <title>Leetcode 计数排序3</title>
      <link>http://example.org/posts/leetcode-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F3/</link>
      <pubDate>Tue, 19 Dec 2023 15:45:23 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F3/</guid>
      <description>数组的相对排序 给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。
对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。
use std::collections::HashMap; use std::collections::HashSet; impl Solution { pub fn relative_sort_array(arr1: Vec&amp;lt;i32&amp;gt;, arr2: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; { let mut map = HashMap::new(); let mut set = HashSet::new(); let mut rv = Vec::new(); let mut post = Vec::new(); for a in &amp;amp;arr2 { set.insert(a); } for a in arr1 { if let Some(x) = map.</description>
    </item>
    
    <item>
      <title>Leetcode 计数排序4</title>
      <link>http://example.org/posts/leetcode-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F4/</link>
      <pubDate>Tue, 19 Dec 2023 15:45:23 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F4/</guid>
      <description>H 指数 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。
根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数 是其中最大的那个。
impl Solution { pub fn h_index(citations: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { let mut left_index = 0; let mut right_index = citations.len(); let mut ans = 0; while left_index &amp;lt;= right_index { let mid = left_index + (right_index - left_index) / 2; let mut tmp_count = 0; for &amp;amp;item in citations.</description>
    </item>
    
    <item>
      <title>Leetcode 最小生成树1</title>
      <link>http://example.org/posts/leetcode-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%911/</link>
      <pubDate>Tue, 19 Dec 2023 15:44:58 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%911/</guid>
      <description>连接所有点的最小费用 给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [x⌄i, y⌄i] 。
连接点 [x⌄i, y⌄i] 和点 [x⌄j, y⌄j] 的费用为它们之间的 曼哈顿距离 ：|x⌄i - x⌄j| + |y⌄i - y⌄j| ，其中 |val| 表示 val 的绝对值。
请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。
impl Solution { pub fn min_cost_connect_points(points: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) -&amp;gt; i32 { let n = points.len(); let mut dist = vec![i32::MAX; n]; let mut edges = vec![]; Self::build_edges(&amp;amp;mut edges, points.iter().map(|x| (x[0], x[1])).collect()); Self::build_edges(&amp;amp;mut edges, points.iter().map(|x| (x[1], x[0])).collect()); Self::build_edges(&amp;amp;mut edges, points.</description>
    </item>
    
    <item>
      <title>Leetcode 扫描线1</title>
      <link>http://example.org/posts/leetcode-%E6%89%AB%E6%8F%8F%E7%BA%BF1/</link>
      <pubDate>Tue, 19 Dec 2023 15:44:18 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%89%AB%E6%8F%8F%E7%BA%BF1/</guid>
      <description>包含每个查询的最小区间 给你一个二维整数数组 intervals ，其中 intervals[i] = [left⌄i, right⌄i] 表示第 i 个区间开始于 left⌄i 、结束于 right⌄i（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 right⌄i - left⌄i + 1 。
再给你一个整数数组 queries 。第 j 个查询的答案是满足 left⌄i &amp;lt;= queries[j] &amp;lt;= right⌄i 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。
以数组形式返回对应查询的所有答案。
struct Query{ int val; int index; int len; bool operator &amp;lt; (const Query&amp;amp; q) const{ return val &amp;lt; q.val; } }; struct Interval{ int tail; int len; bool operator &amp;lt; (const Interval&amp;amp; i) const{ return len &amp;gt; i.</description>
    </item>
    
    <item>
      <title>Leetcode 扫描线2</title>
      <link>http://example.org/posts/leetcode-%E6%89%AB%E6%8F%8F%E7%BA%BF2/</link>
      <pubDate>Tue, 19 Dec 2023 15:44:18 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%89%AB%E6%8F%8F%E7%BA%BF2/</guid>
      <description>矩形面积 II 给你一个轴对齐的二维数组 rectangles 。 对于 rectangle[i] = [x1, y1, x2, y2]，其中（x1，y1）是矩形 i 左下角的坐标， (x⌄i1, y⌄i1) 是该矩形 左下角 的坐标， (x⌄i2, y⌄i2) 是该矩形 右上角 的坐标。
计算平面中所有 rectangles 所覆盖的 总面积 。任何被两个或多个矩形覆盖的区域应只计算 一次 。
返回 总面积 。因为答案可能太大，返回 10^9 + 7 的 模 。
impl Solution { pub fn rectangle_area(rectangles: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) -&amp;gt; i32 { let mut heights = vec![]; for v in rectangles.iter() { heights.push(v[1]); heights.push(v[3]); } heights.sort(); let mut rs = rectangles; rs.sort_by(|a, b| a[0].</description>
    </item>
    
    <item>
      <title>Leetcode 扫描线3</title>
      <link>http://example.org/posts/leetcode-%E6%89%AB%E6%8F%8F%E7%BA%BF3/</link>
      <pubDate>Tue, 19 Dec 2023 15:44:18 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%89%AB%E6%8F%8F%E7%BA%BF3/</guid>
      <description>天际线问题 城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。
每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：
left⌄i 是第 i 座建筑物左边缘的 x 坐标。 right⌄i 是第 i 座建筑物右边缘的 x 坐标。 height⌄i 是第 i 座建筑物的高度。 你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。
天际线 应该表示为由 “关键点” 组成的列表，格式 [[x⌄1,y⌄1],[x⌄2,y⌄2],&amp;hellip;] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。
注意：输出天际线中不得有连续的相同高度的水平线。例如 [&amp;hellip;[2 3], [4 5], [7 5], [11 5], [12 7]&amp;hellip;] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[&amp;hellip;[2 3], [4 5], [12 7], &amp;hellip;]
impl Solution { pub fn get_skyline(buildings: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) -&amp;gt; Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; { let mut boundaries:Vec&amp;lt;i32&amp;gt; = buildings.</description>
    </item>
    
    <item>
      <title>Leetcode 扫描线4</title>
      <link>http://example.org/posts/leetcode-%E6%89%AB%E6%8F%8F%E7%BA%BF4/</link>
      <pubDate>Tue, 19 Dec 2023 15:44:18 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%89%AB%E6%8F%8F%E7%BA%BF4/</guid>
      <description>完美矩形 给你一个数组 rectangles ，其中 rectangles[i] = [x⌄i, y⌄i, a⌄i, b⌄i] 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 (x⌄i, y⌄i) ，右上顶点是 (a⌄i, b⌄i) 。
如果所有矩形一起精确覆盖了某个矩形区域，则返回 true ；否则，返回 false 。
// 格林公式 use std::collections::HashSet; impl Solution { pub fn is_rectangle_cover(rectangles: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) -&amp;gt; bool { let (x1, y1, x2, y2, a, s) = rectangles .iter() .fold((i32::MAX, i32::MAX, i32::MIN, i32::MIN, 0, HashSet::new()), |(x1, y1, x2, y2, a, mut s), rect| { for p in [(rect[0], rect[1]), (rect[2], rect[1]), (rect[0], rect[3]), (rect[2], rect[3])] { if !</description>
    </item>
    
    <item>
      <title>Leetcode Shell1</title>
      <link>http://example.org/posts/leetcode-shell1/</link>
      <pubDate>Tue, 19 Dec 2023 15:22:29 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-shell1/</guid>
      <description>第十行 给定一个文本文件 file.txt，请只打印这个文件中的第十行。
sed -n &amp;#39;10p&amp;#39; file.txt </description>
    </item>
    
    <item>
      <title>Leetcode Shell2</title>
      <link>http://example.org/posts/leetcode-shell2/</link>
      <pubDate>Tue, 19 Dec 2023 15:22:29 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-shell2/</guid>
      <description>统计词频 写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。
为了简单起见，你可以假设：
words.txt只包括小写字母和 &amp;rsquo; &amp;rsquo; 。 每个单词只由小写字母组成。 单词间由一个或多个空格字符分隔。 示例:
假设 words.txt 内容如下：
the day is sunny the the the sunny is is 你的脚本应当输出（以词频降序排列）：
the 4 is 3 sunny 2 day 1 说明:
不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。 你可以使用一行 Unix pipes 实现吗？
cat words.txt | tr -s &amp;#39; &amp;#39; &amp;#39;\n&amp;#39;|sort|uniq -c |sort -r|awk &amp;#39;{print $2&amp;#34; &amp;#34;$1}&amp;#39; cat ——浏览文件 tr -s ——替换字符串（空格换为换行）保证了一行一个单词 sort ——默认ASCII值排序，排序号后还会有重复 uniq —— 去重，-c再输出重复次数。结果就是 ”4 abc“ abc出现了4次 sort -r —— 反向排序，也就是从大到小。得到按频率高低的结果 awk ——格式化输出，规定输出是先字符串再重复次数，所以先$2再$1，中间空格分隔 </description>
    </item>
    
    <item>
      <title>Leetcode Shell3</title>
      <link>http://example.org/posts/leetcode-shell3/</link>
      <pubDate>Tue, 19 Dec 2023 15:22:29 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-shell3/</guid>
      <description>有效电话号码 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。
你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）
你也可以假设每行前后没有多余的空格字符。
// 三种方法 grep -P &amp;#39;^(\d{3}-|\(\d{3}\) )\d{3}-\d{4}$&amp;#39; file.txt sed -n -r &amp;#39;/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/p&amp;#39; file.txt awk &amp;#39;/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-([0-9]{4})$/&amp;#39; file.txt </description>
    </item>
    
    <item>
      <title>Leetcode Shell4</title>
      <link>http://example.org/posts/leetcode-shell4/</link>
      <pubDate>Tue, 19 Dec 2023 15:22:29 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-shell4/</guid>
      <description>转置文件 给定一个文件 file.txt，转置它的内容。
你可以假设每行列数相同，并且每个字段由 &amp;rsquo; &amp;rsquo; 分隔。
# Read from the file file.txt and print its transposed content to stdout. awk &amp;#39;{ #这个大括号里的代码是 对正文的处理 # NF表示列数，NR表示已读的行数 # 注意for中的i从1开始，i前没有类型 for (i=1; i&amp;lt;=NF; i++){#对每一列 if(NR==1){ #如果是第一行 #将第i列的值存入res[i],$i表示第i列的值，i为数组的下标，以列序号为下标， #数组不用定义可以直接使用 res[i]=$i; } else{ #不是第一行时，将该行对应i列的值拼接到res[i] res[i]=res[i] &amp;#34; &amp;#34; $i } } } # BEGIN{} 文件进行扫描前要执行的操作；END{} 文件扫描结束后要执行的操作。 END{ #输出数组 for (i=1; i&amp;lt;=NF; i++){ print res[i] } }&amp;#39; file.txt </description>
    </item>
    
    <item>
      <title>Leetcode 水塘抽样1</title>
      <link>http://example.org/posts/leetcode-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B71/</link>
      <pubDate>Tue, 19 Dec 2023 15:21:14 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B71/</guid>
      <description>非重叠矩形中的随机点 给定一个由非重叠的轴对齐矩形的数组 rects ，其中 rects[i] = [ai, bi, xi, yi] 表示 (ai, bi) 是第 i 个矩形的左下角点，(xi, yi) 是第 i 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。
在给定的矩形覆盖的空间内的任何整数点都有可能被返回。
请注意 ，整数点是具有整数坐标的点。
实现 Solution 类:
Solution(int[][] rects) 用给定的矩形数组 rects 初始化对象。 int[] pick() 返回一个随机的整数点 [u, v] 在给定的矩形所覆盖的空间内。
use rand::{thread_rng, Rng}; struct Solution { rects: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;, arr: Vec&amp;lt;i32&amp;gt;, } impl Solution { fn new(rects: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) -&amp;gt; Self { let arr = rects .iter() .scan(0, |v, rect| { *v += (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1); Some(*v) }) .</description>
    </item>
    
    <item>
      <title>Leetcode 水塘抽样2</title>
      <link>http://example.org/posts/leetcode-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B72/</link>
      <pubDate>Tue, 19 Dec 2023 15:21:14 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B72/</guid>
      <description>链表随机节点 给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。
实现 Solution 类：
Solution(ListNode head) 使用整数数组初始化对象。 int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。
struct Solution { list: Vec&amp;lt;i32&amp;gt;, } impl Solution { fn new(mut head: Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt;) -&amp;gt; Self { let mut list = Vec::new(); while let Some(mut node) = head { list.push(node.val); head = node.next.take(); } Self { list } } fn get_random(&amp;amp;self) -&amp;gt; i32 { use rand::{Rng, thread_rng}; self.list[thread_rng().gen_range(0, self.list.len())] } } </description>
    </item>
    
    <item>
      <title>Leetcode 水塘抽样3</title>
      <link>http://example.org/posts/leetcode-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B73/</link>
      <pubDate>Tue, 19 Dec 2023 15:21:14 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B73/</guid>
      <description>随机翻转矩阵 给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。
尽量最少调用内置的随机函数，并且优化时间和空间复杂度。
实现 Solution 类：
Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象 int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1 void reset() 将矩阵中所有的值重置为 0
use rand::prelude::*; use std::collections::HashMap; struct Solution { n: usize, idx: HashMap&amp;lt;usize, usize&amp;gt;, rng: ThreadRng, r: usize, c: usize, } impl Solution { fn new(m: i32, n: i32) -&amp;gt; Self { Solution { n: m as usize * n as usize, idx: HashMap::new(), rng: thread_rng(), r: m as usize, c: n as usize, } } fn flip(&amp;amp;mut self) -&amp;gt; Vec&amp;lt;i32&amp;gt; { let v = self.</description>
    </item>
    
    <item>
      <title>Leetcode 水塘抽样4</title>
      <link>http://example.org/posts/leetcode-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B74/</link>
      <pubDate>Tue, 19 Dec 2023 15:21:14 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B74/</guid>
      <description>随机数索引 给你一个可能含有 重复元素 的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组中。
实现 Solution 类：
Solution(int[] nums) 用数组 nums 初始化对象。 int pick(int target) 从 nums 中选出一个满足 nums[i] == target 的随机索引 i 。如果存在多个有效的索引，则每个索引的返回概率应当相等。
use rand::{rngs::ThreadRng, Rng}; use std::collections::HashMap; struct Solution { map: HashMap&amp;lt;i32, Vec&amp;lt;usize&amp;gt;&amp;gt;, rand: ThreadRng, } impl Solution { fn new(nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Self { Solution { map: nums .iter() .enumerate() .fold(HashMap::new(), |mut m, (i, &amp;amp;n)| { m.entry(n).and_modify(|v| v.push(i)).or_insert(vec![i]); m }), rand: rand::thread_rng(), } } fn pick(&amp;amp;mut self, target: i32) -&amp;gt; i32 { let v = self.</description>
    </item>
    
    <item>
      <title>Leetcode 强连通分量1</title>
      <link>http://example.org/posts/leetcode-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F1/</link>
      <pubDate>Tue, 19 Dec 2023 15:20:40 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F1/</guid>
      <description>使陆地分离的最少天数 给你一个大小为 m x n ，由若干 0 和 1 组成的二维网格 grid ，其中 1 表示陆地， 0 表示水。岛屿 由水平方向或竖直方向上相邻的 1 （陆地）连接形成。
如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。
一天内，可以将 任何单个 陆地单元（1）更改为水单元（0）。
返回使陆地分离的最少天数。
示例1: 输入：grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]] 输出：2 解释：至少需要 2 天才能得到分离的陆地。 将陆地 grid[1][1] 和 grid[0][2] 更改为水，得到两个分离的岛屿。
示例2: 输入：grid = [[1,1]] 输出：2 解释：如果网格中都是水，也认为是分离的 ([[1,1]] -&amp;gt; [[0,0]])，0 岛屿。
impl Solution { pub fn min_days(grid: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) -&amp;gt; i32 { let (m, n) = (grid.len(), grid[0].len()); let mut relabel = vec!</description>
    </item>
    
    <item>
      <title>Leetcode 强连通分量2</title>
      <link>http://example.org/posts/leetcode-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F2/</link>
      <pubDate>Tue, 19 Dec 2023 15:20:40 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F2/</guid>
      <description>找到最小生成树里的关键边和伪关键边 给你一个 n 个点的带权无向连通图，节点编号为 0 到 n-1 ，同时还有一个数组 edges ，其中 edges[i] = [from⌄i, to⌄i, weight⌄i] 表示在 from⌄i 和 to⌄i 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。
请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。
请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。
impl Solution { pub fn find_critical_and_pseudo_critical_edges(n: i32, edges: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) -&amp;gt; Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; { let mut edges: Vec&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt; = edges .into_iter() .enumerate() .map(|(i, mut x)| { x.push(i as i32); x.into_iter().map(|e| e as usize).collect() }) .collect(); edges.sort_by_key(|x| x[2]); let n = n as usize; let m = edges.len(); let mut label = vec!</description>
    </item>
    
    <item>
      <title>Leetcode 欧拉回路1</title>
      <link>http://example.org/posts/leetcode-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF1/</link>
      <pubDate>Tue, 19 Dec 2023 15:20:02 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF1/</guid>
      <description>合法重新排列数对 给你一个下标从 0 开始的二维整数数组 pairs ，其中 pairs[i] = [start⌄i, end⌄i] 。如果 pairs 的一个重新排列，满足对每一个下标 i （ 1 &amp;lt;= i &amp;lt; pairs.length ）都有 end⌄i-1 == start⌄i ，那么我们就认为这个重新排列是 pairs 的一个 合法重新排列 。
请你返回 任意一个 pairs 的合法重新排列。
注意：数据保证至少存在一个 pairs 的合法重新排列。
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; validArrangement(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; pairs) { // 存储图 unordered_map&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; edges; // 存储入度和出度 unordered_map&amp;lt;int, int&amp;gt; indeg, outdeg; for (const auto&amp;amp; p: pairs) { int x = p[0], y = p[1]; edges[x].push_back(y); ++indeg[y]; ++outdeg[x]; } // 寻找起始节点 int start = pairs[0][0]; for (const auto&amp;amp; [x, occ]: outdeg) { // 如果有节点出度比入度恰好多 1，那么只有它才能是起始节点 if (occ == indeg[x] + 1) { start = x; break; } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; // 深度优先搜索（Hierholzer 算法）求解欧拉通路 function&amp;lt;void(int)&amp;gt; dfs = [&amp;amp;](int u) { while (!</description>
    </item>
    
    <item>
      <title>Leetcode 欧拉回路2</title>
      <link>http://example.org/posts/leetcode-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF2/</link>
      <pubDate>Tue, 19 Dec 2023 15:20:02 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF2/</guid>
      <description>破解保险箱 有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位都是范围 [0, k - 1] 中的一个数字。
保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住 最后 n 位输入 ，如果匹配，则能够打开保险箱。
例如，正确的密码是 &amp;ldquo;345&amp;rdquo; ，并且你输入的是 &amp;ldquo;012345&amp;rdquo; ： 输入 0 之后，最后 3 位输入是 &amp;ldquo;0&amp;rdquo; ，不正确。 输入 1 之后，最后 3 位输入是 &amp;ldquo;01&amp;rdquo; ，不正确。 输入 2 之后，最后 3 位输入是 &amp;ldquo;012&amp;rdquo; ，不正确。 输入 3 之后，最后 3 位输入是 &amp;ldquo;123&amp;rdquo; ，不正确。 输入 4 之后，最后 3 位输入是 &amp;ldquo;234&amp;rdquo; ，不正确。 输入 5 之后，最后 3 位输入是 &amp;ldquo;345&amp;rdquo; ，正确，打开保险箱。 在只知道密码位数 n 和范围边界 k 的前提下，请你找出并返回确保在输入的 某个时刻 能够打开保险箱的任一 最短 密码序列 。</description>
    </item>
    
    <item>
      <title>Leetcode 欧拉回路3</title>
      <link>http://example.org/posts/leetcode-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF3/</link>
      <pubDate>Tue, 19 Dec 2023 15:20:02 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF3/</guid>
      <description>重新安排行程 给你一份航线列表 tickets ，其中 tickets[i] = [from⌄i, to⌄i] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。
所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。
例如，行程 [&amp;ldquo;JFK&amp;rdquo;, &amp;ldquo;LGA&amp;rdquo;] 与 [&amp;ldquo;JFK&amp;rdquo;, &amp;ldquo;LGB&amp;rdquo;] 相比就更小，排序更靠前。 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。
示例1: 输入：tickets = [[&amp;ldquo;MUC&amp;rdquo;,&amp;ldquo;LHR&amp;rdquo;],[&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;MUC&amp;rdquo;],[&amp;ldquo;SFO&amp;rdquo;,&amp;ldquo;SJC&amp;rdquo;],[&amp;ldquo;LHR&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;]] 输出：[&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;MUC&amp;rdquo;,&amp;ldquo;LHR&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;,&amp;ldquo;SJC&amp;rdquo;]
示例2: 输入：tickets = [[&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;],[&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;ATL&amp;rdquo;],[&amp;ldquo;SFO&amp;rdquo;,&amp;ldquo;ATL&amp;rdquo;],[&amp;ldquo;ATL&amp;rdquo;,&amp;ldquo;JFK&amp;rdquo;],[&amp;ldquo;ATL&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;]] 输出：[&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;ATL&amp;rdquo;,&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;,&amp;ldquo;ATL&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;] 解释：另一种有效的行程是 [&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;,&amp;ldquo;ATL&amp;rdquo;,&amp;ldquo;JFK&amp;rdquo;,&amp;ldquo;ATL&amp;rdquo;,&amp;ldquo;SFO&amp;rdquo;] ，但是它字典排序更大更靠后。
// Hierholzer算法 impl Solution { pub fn find_itinerary(tickets: Vec&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;) -&amp;gt; Vec&amp;lt;String&amp;gt; { let mut hash_table = std::collections::HashMap::new(); for ticket in tickets { hash_table.entry(ticket[0].to_string()) .or_insert(Vec::new()) .push(ticket[1].to_string()); } for destination in hash_table.values_mut() { destination.sort_by(|a, b| a.</description>
    </item>
    
    <item>
      <title>Leetcode 基数排序1</title>
      <link>http://example.org/posts/leetcode-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F1/</link>
      <pubDate>Tue, 19 Dec 2023 15:14:04 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F1/</guid>
      <description>裁剪数字后查询第 K 小的数字 给你一个下标从 0 开始的字符串数组 nums ，其中每个字符串 长度相等 且只包含数字。
再给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [k^i, trim^i] 。对于每个 queries[i] ，你需要：
将 nums 中每个数字 裁剪 到剩下 最右边 trim^i 个数位。 在裁剪过后的数字中，找到 nums 中第 k^i 小数字对应的 下标 。如果两个裁剪后数字一样大，那么下标 更小 的数字视为更小的数字。 将 nums 中每个数字恢复到原本字符串。 请你返回一个长度与 queries 相等的数组 answer，其中 answer[i]是第 i 次查询的结果。
提示：
裁剪到剩下最右边 x 个数位的意思是不断删除最左边的数位，直到剩下 x 个数位。 nums 中的字符串可能会有前导 0 。
impl Solution { pub fn smallest_trimmed_numbers(nums: Vec&amp;lt;String&amp;gt;, queries: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; { let l = nums.</description>
    </item>
    
    <item>
      <title>Leetcode 基数排序2</title>
      <link>http://example.org/posts/leetcode-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F2/</link>
      <pubDate>Tue, 19 Dec 2023 15:14:04 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F2/</guid>
      <description>最大间距 给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。
您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。
impl Solution { pub fn maximum_gap(mut nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { let mut buckets = vec![vec![];10]; for i in 0..10 { nums.iter().for_each(|&amp;amp;num| buckets[((num / 10_i32.pow(i)) % 10) as usize].push(num)); buckets.iter().flat_map(|bucket| bucket.iter()).zip(nums.iter_mut()).for_each(|(&amp;amp;a, b)| *b = a); buckets.iter_mut().for_each(|bucket| bucket.clear()); } nums.windows(2).map(|w| w[1] - w[0]).max().unwrap_or(0) } } </description>
    </item>
    
    <item>
      <title>Leetcode 双连通分量1</title>
      <link>http://example.org/posts/leetcode-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F1/</link>
      <pubDate>Tue, 19 Dec 2023 15:12:57 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F1/</guid>
      <description>查找集群内的关键连接 数据中心有 n 台服务器，分别按从 0 到 n-1 的方式进行了编号。它们之间以 服务器到服务器 的形式相互连接组成了一个内部集群，连接是无向的。用 connections 表示集群网络，connections[i] = [a, b] 表示服务器 a 和 b 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。
关键连接 是在该集群中的重要连接，假如我们将它移除，便会导致某些服务器无法访问其他服务器。
请你以任意顺序返回该集群内的所有 关键连接 。
use std::iter::repeat; static mut DFN: [i32; 100010] = [0; 100010]; static mut LOW: [i32; 100010] = [0; 100010]; static mut DFN_CNT: i32 = 0; impl Solution { pub fn critical_connections(n: i32, connections: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) -&amp;gt; Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; { return unsafe{Solution::critical_connections2(n,connections)}; } pub unsafe fn critical_connections2(n: i32, connections: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) -&amp;gt; Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; { let mut graph: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; = repeat(vec!</description>
    </item>
    
    <item>
      <title>Leetcode 双连通分量2</title>
      <link>http://example.org/posts/leetcode-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F2/</link>
      <pubDate>Tue, 19 Dec 2023 15:12:57 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F2/</guid>
      <description>夺回据点 欢迎各位勇者来到力扣城，本次试炼主题为「夺回据点」。
魔物了占领若干据点，这些据点被若干条道路相连接，roads[i] = [x, y] 表示编号 x、y 的两个据点通过一条道路连接。
现在勇者要将按照以下原则将这些据点逐一夺回：
在开始的时候，勇者可以花费资源先夺回一些据点，初始夺回第 j 个据点所需消耗的资源数量为 cost[j]
接下来，勇者在不消耗资源情况下，每次可以夺回一个和「已夺回据点」相连接的魔物据点，并对其进行夺回
注：为了防止魔物暴动，勇者在每一次夺回据点后（包括花费资源夺回据点后），需要保证剩余的所有魔物据点之间是相连通的（不经过「已夺回据点」）。
请返回勇者夺回所有据点需要消耗的最少资源数量。
注意：
输入保证初始所有据点都是连通的，且不存在重边和自环 示例 1：
输入： cost = [1,2,3,4,5,6] roads = [[0,1],[0,2],[1,3],[2,3],[1,2],[2,4],[2,5]]
输出：6
解释： 勇者消耗资源 6 夺回据点 0 和 4，魔物据点 1、2、3、5 相连通； 第一次夺回据点 1，魔物据点 2、3、5 相连通； 第二次夺回据点 3，魔物据点 2、5 相连通； 第三次夺回据点 2，剩余魔物据点 5； 第四次夺回据点 5，无剩余魔物据点； 因此最少需要消耗资源为 6，可占领所有据点。
// Trajan算法 class Solution { const int S = 0; int n; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; e; vector&amp;lt;bool&amp;gt; isCut; vector&amp;lt;int&amp;gt; dfn, low; int clk = 0; stack&amp;lt;int&amp;gt; stk; // 所有点双连通分量 vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dcc; void tarjan(int sn) { dfn[sn] = low[sn] = ++clk; stk.</description>
    </item>
    
    <item>
      <title>Leetcode 拒绝采样2</title>
      <link>http://example.org/posts/leetcode-%E6%8B%92%E7%BB%9D%E9%87%87%E6%A0%B72/</link>
      <pubDate>Mon, 12 Jun 2023 10:56:46 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%8B%92%E7%BB%9D%E9%87%87%E6%A0%B72/</guid>
      <description>在圆内随机生成点 给定圆的半径和圆心的位置，实现函数 randPoint ，在圆中产生均匀随机点。
实现 Solution 类:
Solution(double radius, double x_center, double y_center) 用圆的半径 radius 和圆心的位置 (x_center, y_center) 初始化对象 randPoint() 返回圆内的一个随机点。圆周上的一点被认为在圆内。答案作为数组返回 [x, y] 。
struct Solution { radius: f64, x_center: f64, y_center: f64, } /** * `&amp;amp;self` means the method takes an immutable reference. * If you need a mutable reference, change it to `&amp;amp;mut self` instead. */ impl Solution { fn new(radius: f64, x_center: f64, y_center: f64) -&amp;gt; Self { Solution { radius, x_center, y_center } } fn rand_point(&amp;amp;self) -&amp;gt; Vec&amp;lt;f64&amp;gt; { use rand::{Rng, thread_rng}; use std::f64::consts::PI; let mut rng = thread_rng(); let (len, deg) = (rng.</description>
    </item>
    
    <item>
      <title>Leetcode 拒绝采样1</title>
      <link>http://example.org/posts/leetcode-%E6%8B%92%E7%BB%9D%E9%87%87%E6%A0%B71/</link>
      <pubDate>Mon, 12 Jun 2023 10:56:45 +0800</pubDate>
      
      <guid>http://example.org/posts/leetcode-%E6%8B%92%E7%BB%9D%E9%87%87%E6%A0%B71/</guid>
      <description>用rand7()实现rand10() 给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。
你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。
每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。
impl Solution { pub fn rand10() -&amp;gt; i32 { let mut x = std::i32::MAX; while x &amp;gt; 40 { x = 7 * (rand7() -1) + rand7(); } return x%10+1; } } </description>
    </item>
    
    <item>
      <title>Rust Note 45</title>
      <link>http://example.org/posts/rust-note-45/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:06 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-45/</guid>
      <description>汉明距离 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。
给你两个整数 x 和 y，计算并返回它们之间的汉明距离。
C 解法1： class Solution { public: int hammingDistance(int x, int y) { return __builtin_popcount(x ^ y); } }; C解法2: // Brian Kernighan 算法,跳过两个1之间的0,直接对1进行计数 class Solution { public: int hammingDistance(int x, int y) { int s = x ^ y, ret = 0; while (s) { s &amp;amp;= s - 1; ret++; } return ret; } }; Rust 解法： impl Solution { pub fn hamming_distance(x: i32, y: i32) -&amp;gt; i32 { (x ^ y).</description>
    </item>
    
    <item>
      <title>Rust Note 46</title>
      <link>http://example.org/posts/rust-note-46/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:06 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-46/</guid>
      <description>颠倒二进制位 颠倒给定的 32 位无符号整数的二进制位。
提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
C 解法1： // 逐位颠倒，n(logn) class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t rev = 0; for (int i = 0; i &amp;lt; 32 &amp;amp;&amp;amp; n &amp;gt; 0; ++i) { rev |= (n &amp;amp; 1) &amp;lt;&amp;lt; (31 - i); n &amp;gt;&amp;gt;= 1; } return rev; } }; C解法2: // 分治 class Solution { private: const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111 public: uint32_t reverseBits(uint32_t n) { n = n &amp;gt;&amp;gt; 1 &amp;amp; M1 | (n &amp;amp; M1) &amp;lt;&amp;lt; 1; n = n &amp;gt;&amp;gt; 2 &amp;amp; M2 | (n &amp;amp; M2) &amp;lt;&amp;lt; 2; n = n &amp;gt;&amp;gt; 4 &amp;amp; M4 | (n &amp;amp; M4) &amp;lt;&amp;lt; 4; n = n &amp;gt;&amp;gt; 8 &amp;amp; M8 | (n &amp;amp; M8) &amp;lt;&amp;lt; 8; return n &amp;gt;&amp;gt; 16 | n &amp;lt;&amp;lt; 16; } }; Rust 解法： impl Solution { pub fn reverse_bits(mut x: u32) -&amp;gt; u32 { (0.</description>
    </item>
    
    <item>
      <title>Rust Note 47</title>
      <link>http://example.org/posts/rust-note-47/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:06 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-47/</guid>
      <description>杨辉三角 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
C 解法： class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generate(int numRows) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ret(numRows); for (int i = 0; i &amp;lt; numRows; ++i) { ret[i].resize(i + 1); ret[i][0] = ret[i][i] = 1; for (int j = 1; j &amp;lt; i; ++j) { ret[i][j] = ret[i - 1][j] + ret[i - 1][j - 1]; } } return ret; } }; Rust 解法： impl Solution { pub fn makevec(number: i32) -&amp;gt; Vec&amp;lt;i32&amp;gt; { let mut r = vec!</description>
    </item>
    
    <item>
      <title>Rust Note 48</title>
      <link>http://example.org/posts/rust-note-48/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:06 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-48/</guid>
      <description>有效的括号 给定一个只包括 &amp;lsquo;(&amp;rsquo;，&amp;rsquo;)&amp;rsquo;，&amp;rsquo;{&amp;rsquo;，&amp;rsquo;}&amp;rsquo;，&amp;rsquo;[&amp;rsquo;，&amp;rsquo;]&amp;rsquo; 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。
C 解法： class Solution { public: bool isValid(string s) { int n = s.size(); if (n % 2 == 1) { return false; } unordered_map&amp;lt;char, char&amp;gt; pairs = { {&amp;#39;)&amp;#39;, &amp;#39;(&amp;#39;}, {&amp;#39;]&amp;#39;, &amp;#39;[&amp;#39;}, {&amp;#39;}&amp;#39;, &amp;#39;{&amp;#39;} }; stack&amp;lt;char&amp;gt; stk; for (char ch: s) { if (pairs.count(ch)) { if (stk.empty() || stk.top() != pairs[ch]) { return false; } stk.pop(); } else { stk.</description>
    </item>
    
    <item>
      <title>Rust Note 49</title>
      <link>http://example.org/posts/rust-note-49/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:06 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-49/</guid>
      <description>缺失数字 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
C 解法： // 位运算 class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int res = 0; int n = nums.size(); for (int i = 0; i &amp;lt; n; i++) { res ^= nums[i]; } for (int i = 0; i &amp;lt;= n; i++) { res ^= i; } return res; } }; Rust 解法： impl Solution { pub fn missing_number(nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { [nums.</description>
    </item>
    
    <item>
      <title>Rust Note 41</title>
      <link>http://example.org/posts/rust-note-41/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:05 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-41/</guid>
      <description>计数质数 给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。
C 解法： 解题思路：欧拉筛【时间复杂度O(nlgnlgn)】
埃氏筛 假定我们要求100以内的质数，我们从2开始遍历。 遍历到2,2是质数，于是我们把2的所有倍数全部删除，比如4、6、8、10&amp;hellip;&amp;hellip; 遍历到3,3是质数，于是我们把3的所有倍数全都删除，比如6、9、12、15&amp;hellip;&amp;hellip; 遍历到4,4是合数已经删除,继续遍历，以此类推即可找到范围内所有的素数 欧拉筛 欧拉筛是埃氏筛的改进版本，由于某些合数会有很多质因数，因此在删除的过程中会重复的删除，比如6，遍历到2时会进行删除，遍历到3时也会进行删除，所以为了避免这样的开销，欧拉筛将筛选出来的质数进行记录，在删除的过程中，只通过数的最小质因数筛数。 0、1既不是质数，也不是合数。 一个数，如果只有1和它本身两个约数，这样的数叫质数或素数。一个数，如果除了1和它本身还有别的约数，这样的数叫合数。而0的约数只有0，所以既不是质数又不是合数。如果1是质数，那就要有两个因数：1=1×1；如果1是合数，那就要有三个及以上的因数：1×1×1×1……化简之后就是1=1，只有一个因数，因此，1既不是质数也不是合数。 // 枚举 class Solution { public: bool isPrime(int x) { for (int i = 2; i * i &amp;lt;= x; ++i) { if (x % i == 0) { return false; } } return true; } int countPrimes(int n) { int ans = 0; for (int i = 2; i &amp;lt; n; ++i) { ans += isPrime(i); } return ans; } }; Rust 解法： impl Solution { pub fn count_primes(n: i32) -&amp;gt; i32 { if n &amp;lt;= 2 { return 0; } let n = n as usize; let mut record = vec!</description>
    </item>
    
    <item>
      <title>Rust Note 42</title>
      <link>http://example.org/posts/rust-note-42/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:05 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-42/</guid>
      <description>3的幂 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。
整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3^x
C 解法： // 在题目给定的32位有符号整数的范围内，最大的3的幂为 3^19 =1162261467。我们只需要判断n是否是3的约数即可。 class Solution { public: bool isPowerOfThree(int n) { return n &amp;gt; 0 &amp;amp;&amp;amp; 1162261467 % n == 0; } }; Rust 解法： impl Solution { pub fn is_power_of_three(n: i32) -&amp;gt; bool { if n == 1 { return true; } if n &amp;lt; 3 || n % 3 !</description>
    </item>
    
    <item>
      <title>Rust Note 43</title>
      <link>http://example.org/posts/rust-note-43/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:05 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-43/</guid>
      <description>罗马数字转整数 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。</description>
    </item>
    
    <item>
      <title>Rust Note 44</title>
      <link>http://example.org/posts/rust-note-44/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:05 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-44/</guid>
      <description>位1的个数 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 &amp;lsquo;1&amp;rsquo; 的个数（也被称为汉明重量）。
提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 3 中，输入表示有符号整数 -3。
C 解法： class Solution { public: int hammingWeight(uint32_t n) { int ret = 0; for (int i = 0; i &amp;lt; 32; i++) { if (n &amp;amp; (1 &amp;lt;&amp;lt; i)) { ret++; } } return ret; } }; Rust 解法： // u32::count_ones impl Solution { pub fn hammingWeight (n: u32) -&amp;gt; i32 { n.count_ones() as i32 } } </description>
    </item>
    
    <item>
      <title>Rust Note 31</title>
      <link>http://example.org/posts/rust-note-31/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-31/</guid>
      <description>将有序数组转换为二叉搜索树 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
C 解法： class Solution { public: TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) { return helper(nums, 0, nums.size() - 1); } TreeNode* helper(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right) { if (left &amp;gt; right) { return nullptr; } // 总是选择中间位置左边的数字作为根节点 int mid = (left + right) / 2; TreeNode* root = new TreeNode(nums[mid]); root-&amp;gt;left = helper(nums, left, mid - 1); root-&amp;gt;right = helper(nums, mid + 1, right); return root; } }; Rust 解法： use std::rc::Rc; use std::cell::RefCell; impl Solution { pub fn sorted_array_to_bst(nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt; { fn make_tree(nums:&amp;amp; Vec&amp;lt;i32&amp;gt;, from:i32, to:i32) -&amp;gt; Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;{ match to-from{ 0 =&amp;gt; None, 1 =&amp;gt; Some(Rc::new(RefCell::new(TreeNode::new(nums[from as usize])))), len =&amp;gt; { let center:i32 = (to+from)/2; let mut node = TreeNode::new(nums[center as usize]); node.</description>
    </item>
    
    <item>
      <title>Rust Note 32</title>
      <link>http://example.org/posts/rust-note-32/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-32/</guid>
      <description>合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
C 解法： // 逆向双指针 class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 &amp;gt;= 0 || p2 &amp;gt;= 0) { if (p1 == -1) { cur = nums2[p2--]; } else if (p2 == -1) { cur = nums1[p1--]; } else if (nums1[p1] &amp;gt; nums2[p2]) { cur = nums1[p1--]; } else { cur = nums2[p2--]; } nums1[tail--] = cur; } } }; Rust 解法： use std::cmp::Ordering::{Less, Equal, Greater}; impl Solution { pub fn merge(nums1: &amp;amp;mut Vec&amp;lt;i32&amp;gt;, m: i32, nums2: &amp;amp;mut Vec&amp;lt;i32&amp;gt;, n: i32) { let mut cur1 = m-1; let mut cur2 = (m+n-1) as usize; let mut cur3 = n-1; while cur1&amp;gt;=0 || cur3&amp;gt;=0{ // println!</description>
    </item>
    
    <item>
      <title>Rust Note 33</title>
      <link>http://example.org/posts/rust-note-33/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-33/</guid>
      <description>第一个错误的版本 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, &amp;hellip;, n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
C 解法： class Solution { public: int firstBadVersion(int n) { int left = 1, right = n; while (left &amp;lt; right) { // 循环直至区间左右端点相同 int mid = left + (right - left) / 2; // 防止计算时溢出 if (isBadVersion(mid)) { right = mid; // 答案在区间 [left, mid] 中 } else { left = mid + 1; // 答案在区间 [mid+1, right] 中 } } // 此时有 left == right，区间缩为一个点，即为答案 return left; } }; Rust 解法： // The API isBadVersion is defined for you.</description>
    </item>
    
    <item>
      <title>Rust Note 34</title>
      <link>http://example.org/posts/rust-note-34/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-34/</guid>
      <description>爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
C 解法1： // 通项公式法 class Solution { public: int climbStairs(int n) { double sqrt5 = sqrt(5); double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1); return (int)round(fibn / sqrt5); } }; C解法2: // 矩阵快速幂 class Solution { public: vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; multiply(vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; &amp;amp;a, vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; &amp;amp;b) { vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; c(2, vector&amp;lt;long long&amp;gt;(2)); for (int i = 0; i &amp;lt; 2; i++) { for (int j = 0; j &amp;lt; 2; j++) { c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]; } } return c; } vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; matrixPow(vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; a, int n) { vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; ret = {{1, 0}, {0, 1}}; while (n &amp;gt; 0) { if ((n &amp;amp; 1) == 1) { ret = multiply(ret, a); } n &amp;gt;&amp;gt;= 1; a = multiply(a, a); } return ret; } int climbStairs(int n) { vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; ret = {{1, 1}, {1, 0}}; vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; res = matrixPow(ret, n); return res[0][0]; } }; Rust 解法： impl Solution { pub fn climb_stairs(n: i32) -&amp;gt; i32 { let (mut a, mut b) = (1, 1); (0.</description>
    </item>
    
    <item>
      <title>Rust Note 35</title>
      <link>http://example.org/posts/rust-note-35/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-35/</guid>
      <description>买卖股票的最佳时机 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
C 解法： class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int inf = 1e9; int minprice = inf, maxprofit = 0; for (int price: prices) { maxprofit = max(maxprofit, price - minprice); minprice = min(price, minprice); } return maxprofit; } }; Rust 解法： impl Solution { pub fn max_profit(prices: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { let mut minmin = i32::MAX; let mut maxsell = 0; for price in prices.</description>
    </item>
    
    <item>
      <title>Rust Note 36</title>
      <link>http://example.org/posts/rust-note-36/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-36/</guid>
      <description>最大子序和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。
C 解法1： // 动态规划 class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int pre = 0, maxAns = nums[0]; for (const auto &amp;amp;x: nums) { pre = max(pre + x, x); maxAns = max(maxAns, pre); } return maxAns; } }; C解法2: // 分治法 class Solution { public: struct Status { int lSum, rSum, mSum, iSum; }; Status pushUp(Status l, Status r) { int iSum = l.</description>
    </item>
    
    <item>
      <title>Rust Note 37</title>
      <link>http://example.org/posts/rust-note-37/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-37/</guid>
      <description>打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
C 解法： int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int prev = 0; int curr = 0; // 每次循环，计算“偷到当前房子为止的最大金额” for (int i : nums) { // 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2] // dp[k] = max{ dp[k-1], dp[k-2] + i } int temp = max(curr, prev + i); prev = curr; curr = temp; // 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1] } return curr; } Rust 解法： impl Solution { pub fn rob(nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { nums.</description>
    </item>
    
    <item>
      <title>Rust Note 38</title>
      <link>http://example.org/posts/rust-note-38/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-38/</guid>
      <description>打乱数组 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 等可能 的。
实现 Solution class:
Solution(int[] nums) 使用整数数组 nums 初始化对象 int[] reset() 重设数组到它的初始状态并返回 int[] shuffle() 返回数组随机打乱后的结果
C 解法： // 原地乱序，Fisher-Yates 洗牌算法 class Solution { public: Solution(vector&amp;lt;int&amp;gt;&amp;amp; nums) { this-&amp;gt;nums = nums; this-&amp;gt;original.resize(nums.size()); copy(nums.begin(), nums.end(), original.begin()); } vector&amp;lt;int&amp;gt; reset() { copy(original.begin(), original.end(), nums.begin()); return nums; } vector&amp;lt;int&amp;gt; shuffle() { for (int i = 0; i &amp;lt; nums.size(); ++i) { int j = i + rand() % (nums.size() - i); swap(nums[i], nums[j]); } return nums; } private: vector&amp;lt;int&amp;gt; nums; vector&amp;lt;int&amp;gt; original; }; Rust 解法： use rand::prelude::*; struct Solution { nums: Vec&amp;lt;i32&amp;gt; } /** * `&amp;amp;self` means the method takes an immutable reference.</description>
    </item>
    
    <item>
      <title>Rust Note 39</title>
      <link>http://example.org/posts/rust-note-39/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-39/</guid>
      <description>最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
实现 MinStack 类:
MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。
C 解法： // 辅助栈 class MinStack { stack&amp;lt;int&amp;gt; x_stack; stack&amp;lt;int&amp;gt; min_stack; public: MinStack() { min_stack.push(INT_MAX); } void push(int x) { x_stack.push(x); min_stack.push(min(min_stack.top(), x)); } void pop() { x_stack.pop(); min_stack.pop(); } int top() { return x_stack.top(); } int getMin() { return min_stack.top(); } }; python解法： // 原地，栈里保存差值 class MinStack: def __init__(self): &amp;#34;&amp;#34;&amp;#34; initialize your data structure here.</description>
    </item>
    
    <item>
      <title>Rust Note 40</title>
      <link>http://example.org/posts/rust-note-40/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-40/</guid>
      <description>Fizz Buzz 给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中：
answer[i] == &amp;ldquo;FizzBuzz&amp;rdquo; 如果 i 同时是 3 和 5 的倍数。 answer[i] == &amp;ldquo;Fizz&amp;rdquo; 如果 i 是 3 的倍数。 answer[i] == &amp;ldquo;Buzz&amp;rdquo; 如果 i 是 5 的倍数。 answer[i] == i （以字符串形式）如果上述条件全不满足。
C 解法： class Solution { public: vector&amp;lt;string&amp;gt; fizzBuzz(int n) { vector&amp;lt;string&amp;gt; answer; for (int i = 1; i &amp;lt;= n; i++) { string curr; if (i % 3 == 0) { curr　+= &amp;#34;Fizz&amp;#34;; } if (i % 5 == 0) { curr += &amp;#34;Buzz&amp;#34;; } if (curr.</description>
    </item>
    
    <item>
      <title>Rust Note 30</title>
      <link>http://example.org/posts/rust-note-30/</link>
      <pubDate>Sun, 04 Jun 2023 22:12:33 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-30/</guid>
      <description>二叉树的层序遍历 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
C 解法： class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector &amp;lt;vector &amp;lt;int&amp;gt;&amp;gt; ret; if (!root) { return ret; } queue &amp;lt;TreeNode*&amp;gt; q; q.push(root); while (!q.empty()) { int currentLevelSize = q.size(); ret.push_back(vector &amp;lt;int&amp;gt; ()); for (int i = 1; i &amp;lt;= currentLevelSize; ++i) { auto node = q.front(); q.pop(); ret.back().push_back(node-&amp;gt;val); if (node-&amp;gt;left) q.push(node-&amp;gt;left); if (node-&amp;gt;right) q.push(node-&amp;gt;right); } } return ret; } }; Rust 解法： use std::rc::Rc; use std::cell::RefCell; impl Solution { pub fn level_order(root: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; { let mut q = vec!</description>
    </item>
    
    <item>
      <title>Rust Note 29</title>
      <link>http://example.org/posts/rust-note-29/</link>
      <pubDate>Sun, 04 Jun 2023 22:12:07 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-29/</guid>
      <description>对称二叉树 给你一个二叉树的根节点 root ， 检查它是否轴对称。
C 解法： // 递归 class Solution { public: bool check(TreeNode *p, TreeNode *q) { if (!p &amp;amp;&amp;amp; !q) return true; if (!p || !q) return false; return p-&amp;gt;val == q-&amp;gt;val &amp;amp;&amp;amp; check(p-&amp;gt;left, q-&amp;gt;right) &amp;amp;&amp;amp; check(p-&amp;gt;right, q-&amp;gt;left); } bool isSymmetric(TreeNode* root) { return check(root, root); } }; Rust 解法： use std::cell::RefCell; use std::rc::Rc; impl Solution { fn cmp(left: &amp;amp;Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;, right: &amp;amp;Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; bool { match (&amp;amp;left, &amp;amp;right) { (None, None) =&amp;gt; true, (Some(left), Some(right)) =&amp;gt; { left.</description>
    </item>
    
    <item>
      <title>Rust Note 28</title>
      <link>http://example.org/posts/rust-note-28/</link>
      <pubDate>Sun, 04 Jun 2023 22:11:41 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-28/</guid>
      <description>验证二叉搜索树 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。
C 解法： class Solution { public: bool isValidBST(TreeNode* root) { stack&amp;lt;TreeNode*&amp;gt; stack; long long inorder = (long long)INT_MIN - 1; while (!stack.empty() || root != nullptr) { while (root != nullptr) { stack.push(root); root = root -&amp;gt; left; } root = stack.top(); stack.pop(); // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树 if (root -&amp;gt; val &amp;lt;= inorder) { return false; } inorder = root -&amp;gt; val; root = root -&amp;gt; right; } return true; } }; Rust 解法1： // Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Rust Note 27</title>
      <link>http://example.org/posts/rust-note-27/</link>
      <pubDate>Sun, 04 Jun 2023 22:11:25 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-27/</guid>
      <description>二叉树的最大深度 给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
C 解法： // 深度优先，递归 class Solution { public: int maxDepth(TreeNode* root) { if (root == nullptr) return 0; return max(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right)) + 1; } }; Rust 解法： // Definition for a binary tree node. // #[derive(Debug, PartialEq, Eq)] // pub struct TreeNode { // pub val: i32, // pub left: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;, // pub right: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;, // } // // impl TreeNode { // #[inline] // pub fn new(val: i32) -&amp;gt; Self { // TreeNode { // val, // left: None, // right: None // } // } // } use std::rc::Rc; use std::cell::RefCell; impl Solution { pub fn max_depth(root: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; i32 { Self::max_depth_traverse_impl(&amp;amp;root, 1) } pub fn max_depth_traverse_impl(root: &amp;amp;Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;, mut depth: i32) -&amp;gt; i32 { use std::cmp::Ordering; if let Some(node) = root { let (left, right) = (node.</description>
    </item>
    
    <item>
      <title>Rust Note 26</title>
      <link>http://example.org/posts/rust-note-26/</link>
      <pubDate>Sun, 04 Jun 2023 21:16:32 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-26/</guid>
      <description>环形链表 给你一个链表的头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。
如果链表中存在环 ，则返回 true 。 否则，返回 false 。
C 解法： // 快慢指针，floyd判圈算法 class Solution { public: bool hasCycle(ListNode* head) { if (head == nullptr || head-&amp;gt;next == nullptr) { return false; } ListNode* slow = head; ListNode* fast = head-&amp;gt;next; while (slow != fast) { if (fast == nullptr || fast-&amp;gt;next == nullptr) { return false; } slow = slow-&amp;gt;next; fast = fast-&amp;gt;next-&amp;gt;next; } return true; } }; Rust 解法1： // hash set use std::rc::Rc; use std::cell::RefCell; use std::collections::HashSet; struct ListNode{ val: i32, next: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;ListNode&amp;gt;&amp;gt;&amp;gt;, } impl ListNode{ pub fn new(val: i32) -&amp;gt; ListNode { ListNode { val, next: None, } } } pub fn has_cycle(head: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;ListNode&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; bool { let mut set = HashSet::new(); let mut h = match head { Some(ref node) =&amp;gt; Rc::clone(node), _ =&amp;gt; return false, }; loop { if set.</description>
    </item>
    
    <item>
      <title>Rust Note 25</title>
      <link>http://example.org/posts/rust-note-25/</link>
      <pubDate>Sun, 04 Jun 2023 21:16:10 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-25/</guid>
      <description>回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
C 解法： class Solution { public: bool isPalindrome(ListNode* head) { vector&amp;lt;int&amp;gt; vals; while (head != nullptr) { vals.emplace_back(head-&amp;gt;val); head = head-&amp;gt;next; } for (int i = 0, j = (int)vals.size() - 1; i &amp;lt; j; ++i, --j) { if (vals[i] != vals[j]) { return false; } } return true; } }; Rust 解法： // Definition for singly-linked list. // #[derive(PartialEq, Eq, Clone, Debug)] // pub struct ListNode { // pub val: i32, // pub next: Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt; // } // // impl ListNode { // #[inline] // fn new(val: i32) -&amp;gt; Self { // ListNode { // next: None, // val // } // } // } impl Solution { pub fn is_palindrome(head: Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt;) -&amp;gt; bool { if head == None { return false; } let mut vec = Vec::new(); let mut current = head; while let Some(mut tmp) = current.</description>
    </item>
    
    <item>
      <title>Rust Note 24</title>
      <link>http://example.org/posts/rust-note-24/</link>
      <pubDate>Sun, 04 Jun 2023 21:15:40 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-24/</guid>
      <description>合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
C 解法： class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* preHead = new ListNode(-1); ListNode* prev = preHead; while (l1 != nullptr &amp;amp;&amp;amp; l2 != nullptr) { if (l1-&amp;gt;val &amp;lt; l2-&amp;gt;val) { prev-&amp;gt;next = l1; l1 = l1-&amp;gt;next; } else { prev-&amp;gt;next = l2; l2 = l2-&amp;gt;next; } prev = prev-&amp;gt;next; } // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可 prev-&amp;gt;next = l1 == nullptr ?</description>
    </item>
    
    <item>
      <title>Rust Note 23</title>
      <link>http://example.org/posts/rust-note-23/</link>
      <pubDate>Sun, 04 Jun 2023 21:15:11 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-23/</guid>
      <description>反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
C 解法： class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; ListNode* curr = head; while (curr) { ListNode* next = curr-&amp;gt;next; curr-&amp;gt;next = prev; prev = curr; curr = next; } return prev; } }; Rust 解法： impl Solution { pub fn reverse_list(head: Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt;) -&amp;gt; Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt; { let mut pre = None; let mut head = head; while let Some(mut node) = head { head = node.</description>
    </item>
    
    <item>
      <title>Rust Note 22</title>
      <link>http://example.org/posts/rust-note-22/</link>
      <pubDate>Sun, 04 Jun 2023 21:14:10 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-22/</guid>
      <description>删除链表的倒数第N个节点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
Java 解法： // 回溯后序遍历 public ListNode removeNthFromEnd(ListNode head, int n) { int traverse = traverse(head, n); if(traverse == n) return head.next; return head; } private int traverse(ListNode node, int n) { if(node == null) return 0; int num = traverse(node.next, n); if(num == n) node.next = node.next.next; return num + 1; } Rust 解法： // 快慢指针法 // Definition for singly-linked list. // #[derive(PartialEq, Eq, Clone, Debug)] // pub struct ListNode { // pub val: i32, // pub next: Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt; // } // // impl ListNode { // #[inline] // fn new(val: i32) -&amp;gt; Self { // ListNode { // next: None, // val // } // } // } impl Solution { pub fn remove_nth_from_end(head: Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt;, n: i32) -&amp;gt; Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt; { let mut dummy = Some(Box::new(ListNode{val: 0, next: head})); let mut slow_p = &amp;amp;mut dummy; let mut fast_p = &amp;amp;slow_p.</description>
    </item>
    
    <item>
      <title>Rust Note 21</title>
      <link>http://example.org/posts/rust-note-21/</link>
      <pubDate>Sat, 03 Jun 2023 23:08:47 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-21/</guid>
      <description>删除链表中的节点 有一个单链表的 head，我们想删除它其中的一个节点 node。
给你一个需要删除的节点 node 。你将 无法访问 第一个节点 head。
链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。
删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：
给定节点的值不应该存在于链表中。 链表中的节点数应该减少 1。 node 前面的所有值顺序相同。 node 后面的所有值顺序相同。
C 解法： class Solution { public: void deleteNode(ListNode* node) { node-&amp;gt;val = node-&amp;gt;next-&amp;gt;val; node-&amp;gt;next = node-&amp;gt;next-&amp;gt;next; } }; Rust 解法： </description>
    </item>
    
    <item>
      <title>Rust Note 11</title>
      <link>http://example.org/posts/rustnote11/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote11/</guid>
      <description>旋转图像 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
C 解法： void swap(int* a, int* b) { int t = *a; *a = *b, *b = t; } void rotate(int** matrix, int matrixSize, int* matrixColSize) { // 水平翻转 for (int i = 0; i &amp;lt; matrixSize / 2; ++i) { for (int j = 0; j &amp;lt; matrixSize; ++j) { swap(&amp;amp;matrix[i][j], &amp;amp;matrix[matrixSize - i - 1][j]); } } // 主对角线翻转 for (int i = 0; i &amp;lt; matrixSize; ++i) { for (int j = 0; j &amp;lt; i; ++j) { swap(&amp;amp;matrix[i][j], &amp;amp;matrix[j][i]); } } } Rust 解法： impl Solution { pub fn rotate(matrix: &amp;amp;mut Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) { let m = matrix.</description>
    </item>
    
    <item>
      <title>Rust Note 12</title>
      <link>http://example.org/posts/rustnote12/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote12/</guid>
      <description>反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
C 解法： void swap(char *a, char *b) { char t = *a; *a = *b, *b = t; } void reverseString(char *s, int sSize) { for (int left = 0, right = sSize - 1; left &amp;lt; right; ++left, --right) { swap(s + left, s + right); } } Rust 解法： impl Solution { pub fn reverse_string(s: &amp;amp;mut Vec&amp;lt;char&amp;gt;) { //let sl = s.</description>
    </item>
    
    <item>
      <title>Rust Note 13</title>
      <link>http://example.org/posts/rustnote13/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote13/</guid>
      <description>整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。
C 解法： class Solution { public: int reverse(int x) { int res=0; while(x){ if(x&amp;gt;0 &amp;amp;&amp;amp; res&amp;gt;(INT_MAX-x%10)/10) return 0; if(x&amp;lt;0 &amp;amp;&amp;amp; res&amp;lt;(INT_MIN-x%10)/10) return 0; res = res*10+x%10; x/=10; } return res; } }; Rust 解法： impl Solution { pub fn reverse(x: i32) -&amp;gt; i32 { x.abs() .to_string() .chars().rev() .collect::&amp;lt;String&amp;gt;() .parse::&amp;lt;i32&amp;gt;() .unwrap_or(0) * x.</description>
    </item>
    
    <item>
      <title>Rust Note 14</title>
      <link>http://example.org/posts/rustnote14/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote14/</guid>
      <description>字符串中的第一个唯一字符 给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。
C 解法： class Solution { public: int firstUniqChar(string s) { unordered_map&amp;lt;int, int&amp;gt; frequency; for (char ch: s) { ++frequency[ch]; } for (int i = 0; i &amp;lt; s.size(); ++i) { if (frequency[s[i]] == 1) { return i; } } return -1; } }; Rust 解法1： use std::collections::HashMap; impl Solution { pub fn first_uniq_char(s: String) -&amp;gt; i32 { let mut map = HashMap::new(); s.</description>
    </item>
    
    <item>
      <title>Rust Note 15</title>
      <link>http://example.org/posts/rustnote15/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote15/</guid>
      <description>有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
C 解法： class Solution { public boolean isAnagram(String s, String t) { if(s.length() != t.length()) return false; int[] alpha = new int[26]; for(int i = 0; i&amp;lt; s.length(); i++) { alpha[s.charAt(i) - &amp;#39;a&amp;#39;] ++; alpha[t.charAt(i) - &amp;#39;a&amp;#39;] --; } for(int i=0;i&amp;lt;26;i++) if(alpha[i] != 0) return false; return true; } } Rust 解法： impl Solution { pub fn is_anagram(s: String, t: String) -&amp;gt; bool { if s.</description>
    </item>
    
    <item>
      <title>Rust Note 16</title>
      <link>http://example.org/posts/rustnote16/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote16/</guid>
      <description>验证回文串 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。
字母和数字都属于字母数字字符。
给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。
C 解法： class Solution { public: bool isPalindrome(string s) { int n = s.size(); int left = 0, right = n - 1; while (left &amp;lt; right) { while (left &amp;lt; right &amp;amp;&amp;amp; !isalnum(s[left])) { ++left; } while (left &amp;lt; right &amp;amp;&amp;amp; !isalnum(s[right])) { --right; } if (left &amp;lt; right) { if (tolower(s[left]) != tolower(s[right])) { return false; } ++left; --right; } } return true; } }; Rust 解法： impl Solution { pub fn is_palindrome(s: String) -&amp;gt; bool { let s = s .</description>
    </item>
    
    <item>
      <title>Rust Note 17</title>
      <link>http://example.org/posts/rustnote17/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote17/</guid>
      <description>字符串转换整数 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。
函数 myAtoi(string s) 的算法如下：
读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，&amp;ldquo;123&amp;rdquo; -&amp;gt; 123， &amp;ldquo;0032&amp;rdquo; -&amp;gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。 注意：
本题中的空白字符只包括空格字符 &amp;rsquo; &amp;rsquo; 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。
C 解法： // 自动机 class Automaton { string state = &amp;#34;start&amp;#34;; unordered_map&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; table = { {&amp;#34;start&amp;#34;, {&amp;#34;start&amp;#34;, &amp;#34;signed&amp;#34;, &amp;#34;in_number&amp;#34;, &amp;#34;end&amp;#34;}}, {&amp;#34;signed&amp;#34;, {&amp;#34;end&amp;#34;, &amp;#34;end&amp;#34;, &amp;#34;in_number&amp;#34;, &amp;#34;end&amp;#34;}}, {&amp;#34;in_number&amp;#34;, {&amp;#34;end&amp;#34;, &amp;#34;end&amp;#34;, &amp;#34;in_number&amp;#34;, &amp;#34;end&amp;#34;}}, {&amp;#34;end&amp;#34;, {&amp;#34;end&amp;#34;, &amp;#34;end&amp;#34;, &amp;#34;end&amp;#34;, &amp;#34;end&amp;#34;}} }; int get_col(char c) { if (isspace(c)) return 0; if (c == &amp;#39;+&amp;#39; or c == &amp;#39;-&amp;#39;) return 1; if (isdigit(c)) return 2; return 3; } public: int sign = 1; long long ans = 0; void get(char c) { state = table[state][get_col(c)]; if (state == &amp;#34;in_number&amp;#34;) { ans = ans * 10 + c - &amp;#39;0&amp;#39;; ans = sign == 1 ?</description>
    </item>
    
    <item>
      <title>Rust Note 18</title>
      <link>http://example.org/posts/rustnote18/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote18/</guid>
      <description>实现strStr() 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。
C 解法： // 暴力匹配 class Solution { public: int strStr(string haystack, string needle) { int n = haystack.size(), m = needle.size(); for (int i = 0; i + m &amp;lt;= n; i++) { bool flag = true; for (int j = 0; j &amp;lt; m; j++) { if (haystack[i + j] != needle[j]) { flag = false; break; } } if (flag) { return i; } } return -1; } }; Rust 解法1： // KMP算法 impl Solution { pub fn str_str(haystack: String, needle: String) -&amp;gt; i32 { let haystack = haystack.</description>
    </item>
    
    <item>
      <title>Rust Note 19</title>
      <link>http://example.org/posts/rustnote19/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote19/</guid>
      <description>外观数列 给定一个正整数 n ，输出外观数列的第 n 项。
「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。
你可以将其视作是由递归公式定义的数字字符串序列：
countAndSay(1) = &amp;ldquo;1&amp;rdquo; countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。 前五项如下：
1 11 21 1211 111221 第一项是数字 1 描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &amp;ldquo;11&amp;rdquo; 描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &amp;ldquo;21&amp;rdquo; 描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &amp;ldquo;1211&amp;rdquo; 描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &amp;ldquo;111221&amp;rdquo; 要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</description>
    </item>
    
    <item>
      <title>Rust Note 20</title>
      <link>http://example.org/posts/rustnote20/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote20/</guid>
      <description>最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;quot;。
C 解法： // 先排序，后比较头尾 class Solution { public: string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) { if(strs.empty()) return string(); sort(strs.begin(), strs.end()); string st = strs.front(), en = strs.back(); int i, num = min(st.size(), en.size()); for(i = 0; i &amp;lt; num &amp;amp;&amp;amp; st[i] == en[i]; i ++); return string(st, 0, i); } }; Rust 解法1： impl Solution { pub fn longest_common_prefix(strs: Vec&amp;lt;String&amp;gt;) -&amp;gt; String { let mut x:Vec&amp;lt;_&amp;gt; = strs.iter().map(|c|c.chars()).collect(); let mut res = String::new(); while let Some(t) = x[0].</description>
    </item>
    
    <item>
      <title>Rust Note 10</title>
      <link>http://example.org/posts/rustnote10/</link>
      <pubDate>Fri, 19 May 2023 21:35:55 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote10/</guid>
      <description>有效的数独 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 注意：
一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 空白格用 &amp;lsquo;.&amp;rsquo; 表示。
C 解法： class Solution { public: bool isValidSudoku(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { int row[9][9] = {0}; int col[9][9] = {0}; int box[3][3][9] = {0}; for (int i = 0; i &amp;lt; 9; i++) { for (int j = 0; j &amp;lt; 9; j++) { char c = board[i][j]; if (c == &amp;#39;.</description>
    </item>
    
    <item>
      <title>Rust Note 09</title>
      <link>http://example.org/posts/rustnote09/</link>
      <pubDate>Fri, 19 May 2023 21:35:49 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote09/</guid>
      <description>两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
C 解法： int* twoSum(int* nums, int numsSize, int target, int* returnSize) { for (int i = 0; i &amp;lt; numsSize; ++i) { for (int j = i + 1; j &amp;lt; numsSize; ++j) { if (nums[i] + nums[j] == target) { int* ret = malloc(sizeof(int) * 2); ret[0] = i, ret[1] = j; *returnSize = 2; return ret; } } } *returnSize = 0; return NULL; } Rust 解法： use std::collections::HashMap; impl Solution { pub fn two_sum(nums: Vec&amp;lt;i32&amp;gt;, target: i32) -&amp;gt; Vec&amp;lt;i32&amp;gt; { let mut map = HashMap::new(); for (i,val) in nums.</description>
    </item>
    
    <item>
      <title>Rust Note 08</title>
      <link>http://example.org/posts/rustnote08/</link>
      <pubDate>Fri, 19 May 2023 21:35:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote08/</guid>
      <description>移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。
C 解法： class Solution { public void moveZeroes(int[] nums) { int indexNow = 0; int indexNum = 0; int m = nums.length; while(indexNum&amp;lt;m){ if(nums[indexNum] != 0) { nums[indexNow++] = nums[indexNum]; } ++indexNum; } for(int i = indexNow; i &amp;lt; m; i++){ nums[i] = 0; } } } Rust 解法： impl Solution { pub fn move_zeroes(nums: &amp;amp;mut Vec&amp;lt;i32&amp;gt;) { let len = nums.len(); nums.retain(|x| *x !</description>
    </item>
    
    <item>
      <title>Rust Note 07</title>
      <link>http://example.org/posts/rustnote07/</link>
      <pubDate>Fri, 19 May 2023 21:35:43 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote07/</guid>
      <description>加一 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。
C 解法： int* plusOne(int* digits, int digitsSize, int* returnSize){ for(int i = digitsSize - 1; i &amp;gt;= 0; --i){ digits[i] = digits[i] + 1;//最后元素+1判断是不是10 //如果当前元素不为10，直接返回数组 if(digits[i] != 10){ *returnSize = digitsSize; return digits; } //第一个元素不为10，后面元素均为10的情况 if(digits[i] == 10) digits[i] = 0; } //元素全为9开辟新数组 int* ans = malloc(sizeof(int) * (digitsSize + 1)); memset(ans, 0, sizeof(int) * (digitsSize + 1));//全部置0 ans[0] = 1; *returnSize = digitsSize + 1; return ans; } Rust 解法： impl Solution { pub fn plus_one(digits: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; { match digits.</description>
    </item>
    
    <item>
      <title>Rust Note 06</title>
      <link>http://example.org/posts/rustnote06/</link>
      <pubDate>Fri, 19 May 2023 21:35:39 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote06/</guid>
      <description>两个数组的交集 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。
C解法 ： int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) { int* rearr = (int*)malloc(sizeof(int)*(nums1Size&amp;gt;nums2Size?nums2Size:nums1Size)); int a[1001] = {0}; int b[1001] = {0}; for(int i = 0; i&amp;lt;nums1Size; i++) { a[nums1[i]]++; } for(int i = 0; i&amp;lt;nums2Size; i++) { b[nums2[i]]++; } *returnSize = 0; for(int i = 0; i&amp;lt;1001; i++) { if(a[i]&amp;gt;0&amp;amp;&amp;amp;b[i]&amp;gt;0) { int n = (a[i]&amp;gt;b[i])?b[i]:a[i]; for(int j = 0; j&amp;lt;n ;j++) { rearr[*returnSize] = i; (*returnSize)++; } } } return rearr; } Rust 解法 ： use std::collections::HashMap; impl Solution { pub fn intersect(nums1: Vec&amp;lt;i32&amp;gt;, nums2: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; { let mut ans = vec!</description>
    </item>
    
    <item>
      <title>Rust Note 05</title>
      <link>http://example.org/posts/rustnote05/</link>
      <pubDate>Fri, 19 May 2023 21:35:34 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote05/</guid>
      <description>只出现一次的数字 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
C解法 ： int singleNumber(int* nums, int numsSize){ int a = 0; for (int i = 0; i &amp;lt; numsSize; i++) { a = a ^ nums[i]; } return a; } Rust 解法 ： impl Solution { pub fn single_number(nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { nums.iter().fold(0,|acc,x| acc^x) } } Rust fold() 函数 ： fn fold&amp;lt;B, F&amp;gt;(self, init: B, f: F) -&amp;gt; B where
F: FnMut(B, Self::Item) -&amp;gt; B, 通过应用操作将每个元素 fold 到一个累加器中，返回最终结果。</description>
    </item>
    
    <item>
      <title>Rust Note 04</title>
      <link>http://example.org/posts/rustnote04/</link>
      <pubDate>Fri, 19 May 2023 21:35:29 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote04/</guid>
      <description>存在重复元素 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。
C 解法 ： public boolean containsDuplicate(int[] nums) { Arrays.sort(nums); for (int ind = 1; ind &amp;lt; nums.length; ind++) { if (nums[ind] == nums[ind - 1]) { return true; } } return false; } Rust 解法 1 : impl Solution { pub fn contains_duplicate(mut nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; bool { nums.sort(); (&amp;amp;nums).windows(2).fold(false, |mut res,y|{ (y[0] == y[1]) | res }) } } Rust 解法 2 ： impl Solution { pub fn contains_duplicate(nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; bool { let mut vec = nums.</description>
    </item>
    
    <item>
      <title>Rust Note 03</title>
      <link>http://example.org/posts/rustnote03/</link>
      <pubDate>Fri, 19 May 2023 20:33:16 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote03/</guid>
      <description>买卖股票的最佳时机2 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
返回 你能获得的 最大 利润 。
C 解法 ： public int maxProfit(int[] prices) { if (prices == null || prices.length &amp;lt; 2) return 0; int total = 0, index = 0, length = prices.length; while (index &amp;lt; length) { //如果股票下跌就一直找，直到找到股票开始上涨为止 while (index &amp;lt; length - 1 &amp;amp;&amp;amp; prices[index] &amp;gt;= prices[index + 1]) index++; //股票上涨开始的值，也就是这段时间上涨的最小值 int min = prices[index]; //一直找到股票上涨的最大值为止 while (index &amp;lt; length - 1 &amp;amp;&amp;amp; prices[index] &amp;lt;= prices[index + 1]) index++; //计算这段上涨时间的差值，然后累加 total += prices[index++] - min; } return total; } Rust 解法1 ： impl Solution { pub fn max_profit(prices: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { let mut profit = 0; for i in 1.</description>
    </item>
    
    <item>
      <title>Rust Note 01</title>
      <link>http://example.org/posts/rustnote01/</link>
      <pubDate>Thu, 18 May 2023 19:58:49 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote01/</guid>
      <description>删除排序数组中的重复项 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。
考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：
更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。
C 解法： //双指针解决 public int removeDuplicates(int[] A) { //边界条件判断 if (A == null || A.length == 0) return 0; int left = 0; for (int right = 1; right &amp;lt; A.length; right++) //如果左指针和右指针指向的值一样，说明有重复的， //这个时候，左指针不动，右指针继续往右移。如果他俩 //指向的值不一样就把右指针指向的值往前挪 if (A[left] !</description>
    </item>
    
    <item>
      <title>博文总述</title>
      <link>http://example.org/posts/my-first-post/</link>
      <pubDate>Thu, 18 May 2023 17:06:05 +0800</pubDate>
      
      <guid>http://example.org/posts/my-first-post/</guid>
      <description>博文总述
标签： - rust - leetcode初级算法篇 leetcode算法类型： 见下方超链接类别 </description>
    </item>
    
  </channel>
</rss>
