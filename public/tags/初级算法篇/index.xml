<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>初级算法篇 on Paperubit的博客</title>
    <link>http://example.org/tags/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E7%AF%87/</link>
    <description>Recent content in 初级算法篇 on Paperubit的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 12 Jun 2023 10:35:06 +0800</lastBuildDate><atom:link href="http://example.org/tags/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E7%AF%87/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rust Note 45</title>
      <link>http://example.org/posts/rust-note-45/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:06 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-45/</guid>
      <description>汉明距离 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。
给你两个整数 x 和 y，计算并返回它们之间的汉明距离。
C 解法1： class Solution { public: int hammingDistance(int x, int y) { return __builtin_popcount(x ^ y); } }; C解法2: // Brian Kernighan 算法,跳过两个1之间的0,直接对1进行计数 class Solution { public: int hammingDistance(int x, int y) { int s = x ^ y, ret = 0; while (s) { s &amp;amp;= s - 1; ret++; } return ret; } }; Rust 解法： impl Solution { pub fn hamming_distance(x: i32, y: i32) -&amp;gt; i32 { (x ^ y).</description>
    </item>
    
    <item>
      <title>Rust Note 46</title>
      <link>http://example.org/posts/rust-note-46/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:06 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-46/</guid>
      <description>颠倒二进制位 颠倒给定的 32 位无符号整数的二进制位。
提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
C 解法1： // 逐位颠倒，n(logn) class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t rev = 0; for (int i = 0; i &amp;lt; 32 &amp;amp;&amp;amp; n &amp;gt; 0; ++i) { rev |= (n &amp;amp; 1) &amp;lt;&amp;lt; (31 - i); n &amp;gt;&amp;gt;= 1; } return rev; } }; C解法2:  // 分治 class Solution { private: const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101 const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011 const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111 const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111 public: uint32_t reverseBits(uint32_t n) { n = n &amp;gt;&amp;gt; 1 &amp;amp; M1 | (n &amp;amp; M1) &amp;lt;&amp;lt; 1; n = n &amp;gt;&amp;gt; 2 &amp;amp; M2 | (n &amp;amp; M2) &amp;lt;&amp;lt; 2; n = n &amp;gt;&amp;gt; 4 &amp;amp; M4 | (n &amp;amp; M4) &amp;lt;&amp;lt; 4; n = n &amp;gt;&amp;gt; 8 &amp;amp; M8 | (n &amp;amp; M8) &amp;lt;&amp;lt; 8; return n &amp;gt;&amp;gt; 16 | n &amp;lt;&amp;lt; 16; } }; Rust 解法： impl Solution { pub fn reverse_bits(mut x: u32) -&amp;gt; u32 { (0.</description>
    </item>
    
    <item>
      <title>Rust Note 47</title>
      <link>http://example.org/posts/rust-note-47/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:06 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-47/</guid>
      <description>杨辉三角 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
C 解法： class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generate(int numRows) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ret(numRows); for (int i = 0; i &amp;lt; numRows; ++i) { ret[i].resize(i + 1); ret[i][0] = ret[i][i] = 1; for (int j = 1; j &amp;lt; i; ++j) { ret[i][j] = ret[i - 1][j] + ret[i - 1][j - 1]; } } return ret; } }; Rust 解法： impl Solution { pub fn makevec(number: i32) -&amp;gt; Vec&amp;lt;i32&amp;gt; { let mut r = vec!</description>
    </item>
    
    <item>
      <title>Rust Note 48</title>
      <link>http://example.org/posts/rust-note-48/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:06 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-48/</guid>
      <description>有效的括号 给定一个只包括 &amp;lsquo;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&amp;rsquo; 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。
C 解法： class Solution { public: bool isValid(string s) { int n = s.size(); if (n % 2 == 1) { return false; } unordered_map&amp;lt;char, char&amp;gt; pairs = { {&#39;)&#39;, &#39;(&#39;}, {&#39;]&#39;, &#39;[&#39;}, {&#39;}&#39;, &#39;{&#39;} }; stack&amp;lt;char&amp;gt; stk; for (char ch: s) { if (pairs.count(ch)) { if (stk.empty() || stk.top() != pairs[ch]) { return false; } stk.pop(); } else { stk.</description>
    </item>
    
    <item>
      <title>Rust Note 49</title>
      <link>http://example.org/posts/rust-note-49/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:06 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-49/</guid>
      <description>缺失数字 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
C 解法：  // 位运算 class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int res = 0; int n = nums.size(); for (int i = 0; i &amp;lt; n; i++) { res ^= nums[i]; } for (int i = 0; i &amp;lt;= n; i++) { res ^= i; } return res; } }; Rust 解法： impl Solution { pub fn missing_number(nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { [nums.</description>
    </item>
    
    <item>
      <title>Rust Note 41</title>
      <link>http://example.org/posts/rust-note-41/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:05 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-41/</guid>
      <description>计数质数 给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。
C 解法： 解题思路：欧拉筛【时间复杂度O(nlgnlgn)】
埃氏筛 假定我们要求100以内的质数，我们从2开始遍历。 遍历到2,2是质数，于是我们把2的所有倍数全部删除，比如4、6、8、10&amp;hellip;&amp;hellip; 遍历到3,3是质数，于是我们把3的所有倍数全都删除，比如6、9、12、15&amp;hellip;&amp;hellip; 遍历到4,4是合数已经删除,继续遍历，以此类推即可找到范围内所有的素数 欧拉筛 欧拉筛是埃氏筛的改进版本，由于某些合数会有很多质因数，因此在删除的过程中会重复的删除，比如6，遍历到2时会进行删除，遍历到3时也会进行删除，所以为了避免这样的开销，欧拉筛将筛选出来的质数进行记录，在删除的过程中，只通过数的最小质因数筛数。 0、1既不是质数，也不是合数。 一个数，如果只有1和它本身两个约数，这样的数叫质数或素数。一个数，如果除了1和它本身还有别的约数，这样的数叫合数。而0的约数只有0，所以既不是质数又不是合数。如果1是质数，那就要有两个因数：1=1×1；如果1是合数，那就要有三个及以上的因数：1×1×1×1……化简之后就是1=1，只有一个因数，因此，1既不是质数也不是合数。 
 // 枚举 class Solution { public: bool isPrime(int x) { for (int i = 2; i * i &amp;lt;= x; ++i) { if (x % i == 0) { return false; } } return true; } int countPrimes(int n) { int ans = 0; for (int i = 2; i &amp;lt; n; ++i) { ans += isPrime(i); } return ans; } }; Rust 解法： impl Solution { pub fn count_primes(n: i32) -&amp;gt; i32 { if n &amp;lt;= 2 { return 0; } let n = n as usize; let mut record = vec!</description>
    </item>
    
    <item>
      <title>Rust Note 42</title>
      <link>http://example.org/posts/rust-note-42/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:05 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-42/</guid>
      <description>3的幂 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。
整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3^x
C 解法：  // 在题目给定的32位有符号整数的范围内，最大的3的幂为 3^19 =1162261467。我们只需要判断n是否是3的约数即可。 class Solution { public: bool isPowerOfThree(int n) { return n &amp;gt; 0 &amp;amp;&amp;amp; 1162261467 % n == 0; } }; Rust 解法： impl Solution { pub fn is_power_of_three(n: i32) -&amp;gt; bool { if n == 1 { return true; } if n &amp;lt; 3 || n % 3 !</description>
    </item>
    
    <item>
      <title>Rust Note 43</title>
      <link>http://example.org/posts/rust-note-43/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:05 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-43/</guid>
      <description>罗马数字转整数 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。</description>
    </item>
    
    <item>
      <title>Rust Note 44</title>
      <link>http://example.org/posts/rust-note-44/</link>
      <pubDate>Mon, 12 Jun 2023 10:35:05 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-44/</guid>
      <description>位1的个数 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 &amp;lsquo;1&amp;rsquo; 的个数（也被称为汉明重量）。
 提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 3 中，输入表示有符号整数 -3。
C 解法： class Solution { public: int hammingWeight(uint32_t n) { int ret = 0; for (int i = 0; i &amp;lt; 32; i++) { if (n &amp;amp; (1 &amp;lt;&amp;lt; i)) { ret++; } } return ret; } }; Rust 解法： // u32::count_ones impl Solution { pub fn hammingWeight (n: u32) -&amp;gt; i32 { n.count_ones() as i32 } } </description>
    </item>
    
    <item>
      <title>Rust Note 31</title>
      <link>http://example.org/posts/rust-note-31/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-31/</guid>
      <description>将有序数组转换为二叉搜索树 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
C 解法： class Solution { public: TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) { return helper(nums, 0, nums.size() - 1); } TreeNode* helper(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right) { if (left &amp;gt; right) { return nullptr; } // 总是选择中间位置左边的数字作为根节点 int mid = (left + right) / 2; TreeNode* root = new TreeNode(nums[mid]); root-&amp;gt;left = helper(nums, left, mid - 1); root-&amp;gt;right = helper(nums, mid + 1, right); return root; } }; Rust 解法： use std::rc::Rc; use std::cell::RefCell; impl Solution { pub fn sorted_array_to_bst(nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt; { fn make_tree(nums:&amp;amp; Vec&amp;lt;i32&amp;gt;, from:i32, to:i32) -&amp;gt; Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;{ match to-from{ 0 =&amp;gt; None, 1 =&amp;gt; Some(Rc::new(RefCell::new(TreeNode::new(nums[from as usize])))), len =&amp;gt; { let center:i32 = (to+from)/2; let mut node = TreeNode::new(nums[center as usize]); node.</description>
    </item>
    
    <item>
      <title>Rust Note 32</title>
      <link>http://example.org/posts/rust-note-32/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-32/</guid>
      <description>合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
C 解法：  // 逆向双指针 class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 &amp;gt;= 0 || p2 &amp;gt;= 0) { if (p1 == -1) { cur = nums2[p2--]; } else if (p2 == -1) { cur = nums1[p1--]; } else if (nums1[p1] &amp;gt; nums2[p2]) { cur = nums1[p1--]; } else { cur = nums2[p2--]; } nums1[tail--] = cur; } } }; Rust 解法： use std::cmp::Ordering::{Less, Equal, Greater}; impl Solution { pub fn merge(nums1: &amp;amp;mut Vec&amp;lt;i32&amp;gt;, m: i32, nums2: &amp;amp;mut Vec&amp;lt;i32&amp;gt;, n: i32) { let mut cur1 = m-1; let mut cur2 = (m+n-1) as usize; let mut cur3 = n-1; while cur1&amp;gt;=0 || cur3&amp;gt;=0{ // println!</description>
    </item>
    
    <item>
      <title>Rust Note 33</title>
      <link>http://example.org/posts/rust-note-33/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-33/</guid>
      <description>第一个错误的版本 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, &amp;hellip;, n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
C 解法： class Solution { public: int firstBadVersion(int n) { int left = 1, right = n; while (left &amp;lt; right) { // 循环直至区间左右端点相同 int mid = left + (right - left) / 2; // 防止计算时溢出 if (isBadVersion(mid)) { right = mid; // 答案在区间 [left, mid] 中 } else { left = mid + 1; // 答案在区间 [mid+1, right] 中 } } // 此时有 left == right，区间缩为一个点，即为答案 return left; } }; Rust 解法： // The API isBadVersion is defined for you.</description>
    </item>
    
    <item>
      <title>Rust Note 34</title>
      <link>http://example.org/posts/rust-note-34/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-34/</guid>
      <description>爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
C 解法1： 
 // 通项公式法 class Solution { public: int climbStairs(int n) { double sqrt5 = sqrt(5); double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1); return (int)round(fibn / sqrt5); } }; C解法2: 
 // 矩阵快速幂 class Solution { public: vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; multiply(vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; &amp;amp;a, vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; &amp;amp;b) { vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; c(2, vector&amp;lt;long long&amp;gt;(2)); for (int i = 0; i &amp;lt; 2; i++) { for (int j = 0; j &amp;lt; 2; j++) { c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]; } } return c; } vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; matrixPow(vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; a, int n) { vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; ret = {{1, 0}, {0, 1}}; while (n &amp;gt; 0) { if ((n &amp;amp; 1) == 1) { ret = multiply(ret, a); } n &amp;gt;&amp;gt;= 1; a = multiply(a, a); } return ret; } int climbStairs(int n) { vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; ret = {{1, 1}, {1, 0}}; vector&amp;lt;vector&amp;lt;long long&amp;gt;&amp;gt; res = matrixPow(ret, n); return res[0][0]; } }; Rust 解法： impl Solution { pub fn climb_stairs(n: i32) -&amp;gt; i32 { let (mut a, mut b) = (1, 1); (0.</description>
    </item>
    
    <item>
      <title>Rust Note 35</title>
      <link>http://example.org/posts/rust-note-35/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-35/</guid>
      <description>买卖股票的最佳时机 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
C 解法： class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int inf = 1e9; int minprice = inf, maxprofit = 0; for (int price: prices) { maxprofit = max(maxprofit, price - minprice); minprice = min(price, minprice); } return maxprofit; } }; Rust 解法： impl Solution { pub fn max_profit(prices: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { let mut minmin = i32::MAX; let mut maxsell = 0; for price in prices.</description>
    </item>
    
    <item>
      <title>Rust Note 36</title>
      <link>http://example.org/posts/rust-note-36/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-36/</guid>
      <description>最大子序和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。
C 解法1： // 动态规划 class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int pre = 0, maxAns = nums[0]; for (const auto &amp;amp;x: nums) { pre = max(pre + x, x); maxAns = max(maxAns, pre); } return maxAns; } }; C解法2:  // 分治法 class Solution { public: struct Status { int lSum, rSum, mSum, iSum; }; Status pushUp(Status l, Status r) { int iSum = l.</description>
    </item>
    
    <item>
      <title>Rust Note 37</title>
      <link>http://example.org/posts/rust-note-37/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-37/</guid>
      <description>打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
C 解法： int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int prev = 0; int curr = 0; // 每次循环，计算“偷到当前房子为止的最大金额” for (int i : nums) { // 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2] // dp[k] = max{ dp[k-1], dp[k-2] + i } int temp = max(curr, prev + i); prev = curr; curr = temp; // 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1] } return curr; } Rust 解法： impl Solution { pub fn rob(nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { nums.</description>
    </item>
    
    <item>
      <title>Rust Note 38</title>
      <link>http://example.org/posts/rust-note-38/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-38/</guid>
      <description>打乱数组 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 等可能 的。
实现 Solution class:
Solution(int[] nums) 使用整数数组 nums 初始化对象 int[] reset() 重设数组到它的初始状态并返回 int[] shuffle() 返回数组随机打乱后的结果
C 解法： // 原地乱序，Fisher-Yates 洗牌算法 class Solution { public: Solution(vector&amp;lt;int&amp;gt;&amp;amp; nums) { this-&amp;gt;nums = nums; this-&amp;gt;original.resize(nums.size()); copy(nums.begin(), nums.end(), original.begin()); } vector&amp;lt;int&amp;gt; reset() { copy(original.begin(), original.end(), nums.begin()); return nums; } vector&amp;lt;int&amp;gt; shuffle() { for (int i = 0; i &amp;lt; nums.size(); ++i) { int j = i + rand() % (nums.size() - i); swap(nums[i], nums[j]); } return nums; } private: vector&amp;lt;int&amp;gt; nums; vector&amp;lt;int&amp;gt; original; }; Rust 解法： use rand::prelude::*; struct Solution { nums: Vec&amp;lt;i32&amp;gt; } /** * `&amp;amp;self` means the method takes an immutable reference.</description>
    </item>
    
    <item>
      <title>Rust Note 39</title>
      <link>http://example.org/posts/rust-note-39/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-39/</guid>
      <description>最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
实现 MinStack 类:
MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。
C 解法：  // 辅助栈 class MinStack { stack&amp;lt;int&amp;gt; x_stack; stack&amp;lt;int&amp;gt; min_stack; public: MinStack() { min_stack.push(INT_MAX); } void push(int x) { x_stack.push(x); min_stack.push(min(min_stack.top(), x)); } void pop() { x_stack.pop(); min_stack.pop(); } int top() { return x_stack.top(); } int getMin() { return min_stack.top(); } }; python解法：  // 原地，栈里保存差值 class MinStack: def __init__(self): &amp;quot;&amp;quot;&amp;quot; initialize your data structure here.</description>
    </item>
    
    <item>
      <title>Rust Note 40</title>
      <link>http://example.org/posts/rust-note-40/</link>
      <pubDate>Sat, 10 Jun 2023 19:51:15 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-40/</guid>
      <description>Fizz Buzz 给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中：
answer[i] == &amp;ldquo;FizzBuzz&amp;rdquo; 如果 i 同时是 3 和 5 的倍数。 answer[i] == &amp;ldquo;Fizz&amp;rdquo; 如果 i 是 3 的倍数。 answer[i] == &amp;ldquo;Buzz&amp;rdquo; 如果 i 是 5 的倍数。 answer[i] == i （以字符串形式）如果上述条件全不满足。
C 解法： class Solution { public: vector&amp;lt;string&amp;gt; fizzBuzz(int n) { vector&amp;lt;string&amp;gt; answer; for (int i = 1; i &amp;lt;= n; i++) { string curr; if (i % 3 == 0) { curr　+= &amp;quot;Fizz&amp;quot;; } if (i % 5 == 0) { curr += &amp;quot;Buzz&amp;quot;; } if (curr.</description>
    </item>
    
    <item>
      <title>Rust Note 30</title>
      <link>http://example.org/posts/rust-note-30/</link>
      <pubDate>Sun, 04 Jun 2023 22:12:33 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-30/</guid>
      <description>二叉树的层序遍历 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
C 解法： class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector &amp;lt;vector &amp;lt;int&amp;gt;&amp;gt; ret; if (!root) { return ret; } queue &amp;lt;TreeNode*&amp;gt; q; q.push(root); while (!q.empty()) { int currentLevelSize = q.size(); ret.push_back(vector &amp;lt;int&amp;gt; ()); for (int i = 1; i &amp;lt;= currentLevelSize; ++i) { auto node = q.front(); q.pop(); ret.back().push_back(node-&amp;gt;val); if (node-&amp;gt;left) q.push(node-&amp;gt;left); if (node-&amp;gt;right) q.push(node-&amp;gt;right); } } return ret; } }; Rust 解法： use std::rc::Rc; use std::cell::RefCell; impl Solution { pub fn level_order(root: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; { let mut q = vec!</description>
    </item>
    
    <item>
      <title>Rust Note 29</title>
      <link>http://example.org/posts/rust-note-29/</link>
      <pubDate>Sun, 04 Jun 2023 22:12:07 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-29/</guid>
      <description>对称二叉树 给你一个二叉树的根节点 root ， 检查它是否轴对称。
C 解法：  // 递归 class Solution { public: bool check(TreeNode *p, TreeNode *q) { if (!p &amp;amp;&amp;amp; !q) return true; if (!p || !q) return false; return p-&amp;gt;val == q-&amp;gt;val &amp;amp;&amp;amp; check(p-&amp;gt;left, q-&amp;gt;right) &amp;amp;&amp;amp; check(p-&amp;gt;right, q-&amp;gt;left); } bool isSymmetric(TreeNode* root) { return check(root, root); } }; Rust 解法： use std::cell::RefCell; use std::rc::Rc; impl Solution { fn cmp(left: &amp;amp;Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;, right: &amp;amp;Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; bool { match (&amp;amp;left, &amp;amp;right) { (None, None) =&amp;gt; true, (Some(left), Some(right)) =&amp;gt; { left.</description>
    </item>
    
    <item>
      <title>Rust Note 28</title>
      <link>http://example.org/posts/rust-note-28/</link>
      <pubDate>Sun, 04 Jun 2023 22:11:41 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-28/</guid>
      <description>验证二叉搜索树 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。
C 解法： class Solution { public: bool isValidBST(TreeNode* root) { stack&amp;lt;TreeNode*&amp;gt; stack; long long inorder = (long long)INT_MIN - 1; while (!stack.empty() || root != nullptr) { while (root != nullptr) { stack.push(root); root = root -&amp;gt; left; } root = stack.top(); stack.pop(); // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树 if (root -&amp;gt; val &amp;lt;= inorder) { return false; } inorder = root -&amp;gt; val; root = root -&amp;gt; right; } return true; } }; Rust 解法1： // Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Rust Note 27</title>
      <link>http://example.org/posts/rust-note-27/</link>
      <pubDate>Sun, 04 Jun 2023 22:11:25 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-27/</guid>
      <description>二叉树的最大深度 给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
C 解法：  // 深度优先，递归 class Solution { public: int maxDepth(TreeNode* root) { if (root == nullptr) return 0; return max(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right)) + 1; } }; Rust 解法： // Definition for a binary tree node. // #[derive(Debug, PartialEq, Eq)] // pub struct TreeNode { // pub val: i32, // pub left: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;, // pub right: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;, // } // // impl TreeNode { // #[inline] // pub fn new(val: i32) -&amp;gt; Self { // TreeNode { // val, // left: None, // right: None // } // } // } use std::rc::Rc; use std::cell::RefCell; impl Solution { pub fn max_depth(root: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; i32 { Self::max_depth_traverse_impl(&amp;amp;root, 1) } pub fn max_depth_traverse_impl(root: &amp;amp;Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;TreeNode&amp;gt;&amp;gt;&amp;gt;, mut depth: i32) -&amp;gt; i32 { use std::cmp::Ordering; if let Some(node) = root { let (left, right) = (node.</description>
    </item>
    
    <item>
      <title>Rust Note 26</title>
      <link>http://example.org/posts/rust-note-26/</link>
      <pubDate>Sun, 04 Jun 2023 21:16:32 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-26/</guid>
      <description>环形链表 给你一个链表的头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。
如果链表中存在环 ，则返回 true 。 否则，返回 false 。
C 解法：  // 快慢指针，floyd判圈算法 class Solution { public: bool hasCycle(ListNode* head) { if (head == nullptr || head-&amp;gt;next == nullptr) { return false; } ListNode* slow = head; ListNode* fast = head-&amp;gt;next; while (slow != fast) { if (fast == nullptr || fast-&amp;gt;next == nullptr) { return false; } slow = slow-&amp;gt;next; fast = fast-&amp;gt;next-&amp;gt;next; } return true; } }; Rust 解法1：  // hash set use std::rc::Rc; use std::cell::RefCell; use std::collections::HashSet; struct ListNode{ val: i32, next: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;ListNode&amp;gt;&amp;gt;&amp;gt;, } impl ListNode{ pub fn new(val: i32) -&amp;gt; ListNode { ListNode { val, next: None, } } } pub fn has_cycle(head: Option&amp;lt;Rc&amp;lt;RefCell&amp;lt;ListNode&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; bool { let mut set = HashSet::new(); let mut h = match head { Some(ref node) =&amp;gt; Rc::clone(node), _ =&amp;gt; return false, }; loop { if set.</description>
    </item>
    
    <item>
      <title>Rust Note 25</title>
      <link>http://example.org/posts/rust-note-25/</link>
      <pubDate>Sun, 04 Jun 2023 21:16:10 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-25/</guid>
      <description>回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
C 解法： class Solution { public: bool isPalindrome(ListNode* head) { vector&amp;lt;int&amp;gt; vals; while (head != nullptr) { vals.emplace_back(head-&amp;gt;val); head = head-&amp;gt;next; } for (int i = 0, j = (int)vals.size() - 1; i &amp;lt; j; ++i, --j) { if (vals[i] != vals[j]) { return false; } } return true; } }; Rust 解法： // Definition for singly-linked list. // #[derive(PartialEq, Eq, Clone, Debug)] // pub struct ListNode { // pub val: i32, // pub next: Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt; // } // // impl ListNode { // #[inline] // fn new(val: i32) -&amp;gt; Self { // ListNode { // next: None, // val // } // } // } impl Solution { pub fn is_palindrome(head: Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt;) -&amp;gt; bool { if head == None { return false; } let mut vec = Vec::new(); let mut current = head; while let Some(mut tmp) = current.</description>
    </item>
    
    <item>
      <title>Rust Note 24</title>
      <link>http://example.org/posts/rust-note-24/</link>
      <pubDate>Sun, 04 Jun 2023 21:15:40 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-24/</guid>
      <description>合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
C 解法： class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* preHead = new ListNode(-1); ListNode* prev = preHead; while (l1 != nullptr &amp;amp;&amp;amp; l2 != nullptr) { if (l1-&amp;gt;val &amp;lt; l2-&amp;gt;val) { prev-&amp;gt;next = l1; l1 = l1-&amp;gt;next; } else { prev-&amp;gt;next = l2; l2 = l2-&amp;gt;next; } prev = prev-&amp;gt;next; } // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可 prev-&amp;gt;next = l1 == nullptr ?</description>
    </item>
    
    <item>
      <title>Rust Note 23</title>
      <link>http://example.org/posts/rust-note-23/</link>
      <pubDate>Sun, 04 Jun 2023 21:15:11 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-23/</guid>
      <description>反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
C 解法： class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; ListNode* curr = head; while (curr) { ListNode* next = curr-&amp;gt;next; curr-&amp;gt;next = prev; prev = curr; curr = next; } return prev; } }; Rust 解法： impl Solution { pub fn reverse_list(head: Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt;) -&amp;gt; Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt; { let mut pre = None; let mut head = head; while let Some(mut node) = head { head = node.</description>
    </item>
    
    <item>
      <title>Rust Note 22</title>
      <link>http://example.org/posts/rust-note-22/</link>
      <pubDate>Sun, 04 Jun 2023 21:14:10 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-22/</guid>
      <description>删除链表的倒数第N个节点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
Java 解法：  // 回溯后序遍历 public ListNode removeNthFromEnd(ListNode head, int n) { int traverse = traverse(head, n); if(traverse == n) return head.next; return head; } private int traverse(ListNode node, int n) { if(node == null) return 0; int num = traverse(node.next, n); if(num == n) node.next = node.next.next; return num + 1; } Rust 解法：  // 快慢指针法 // Definition for singly-linked list. // #[derive(PartialEq, Eq, Clone, Debug)] // pub struct ListNode { // pub val: i32, // pub next: Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt; // } // // impl ListNode { // #[inline] // fn new(val: i32) -&amp;gt; Self { // ListNode { // next: None, // val // } // } // } impl Solution { pub fn remove_nth_from_end(head: Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt;, n: i32) -&amp;gt; Option&amp;lt;Box&amp;lt;ListNode&amp;gt;&amp;gt; { let mut dummy = Some(Box::new(ListNode{val: 0, next: head})); let mut slow_p = &amp;amp;mut dummy; let mut fast_p = &amp;amp;slow_p.</description>
    </item>
    
    <item>
      <title>Rust Note 21</title>
      <link>http://example.org/posts/rust-note-21/</link>
      <pubDate>Sat, 03 Jun 2023 23:08:47 +0800</pubDate>
      
      <guid>http://example.org/posts/rust-note-21/</guid>
      <description>删除链表中的节点 有一个单链表的 head，我们想删除它其中的一个节点 node。
给你一个需要删除的节点 node 。你将 无法访问 第一个节点 head。
链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。
删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：
给定节点的值不应该存在于链表中。 链表中的节点数应该减少 1。 node 前面的所有值顺序相同。 node 后面的所有值顺序相同。
C 解法： class Solution { public: void deleteNode(ListNode* node) { node-&amp;gt;val = node-&amp;gt;next-&amp;gt;val; node-&amp;gt;next = node-&amp;gt;next-&amp;gt;next; } }; Rust 解法：  </description>
    </item>
    
    <item>
      <title>Rust Note 11</title>
      <link>http://example.org/posts/rustnote11/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote11/</guid>
      <description>旋转图像 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
C 解法： void swap(int* a, int* b) { int t = *a; *a = *b, *b = t; } void rotate(int** matrix, int matrixSize, int* matrixColSize) { // 水平翻转 for (int i = 0; i &amp;lt; matrixSize / 2; ++i) { for (int j = 0; j &amp;lt; matrixSize; ++j) { swap(&amp;amp;matrix[i][j], &amp;amp;matrix[matrixSize - i - 1][j]); } } // 主对角线翻转 for (int i = 0; i &amp;lt; matrixSize; ++i) { for (int j = 0; j &amp;lt; i; ++j) { swap(&amp;amp;matrix[i][j], &amp;amp;matrix[j][i]); } } } Rust 解法： impl Solution { pub fn rotate(matrix: &amp;amp;mut Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) { let m = matrix.</description>
    </item>
    
    <item>
      <title>Rust Note 12</title>
      <link>http://example.org/posts/rustnote12/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote12/</guid>
      <description>反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
C 解法： void swap(char *a, char *b) { char t = *a; *a = *b, *b = t; } void reverseString(char *s, int sSize) { for (int left = 0, right = sSize - 1; left &amp;lt; right; ++left, --right) { swap(s + left, s + right); } } Rust 解法： impl Solution { pub fn reverse_string(s: &amp;amp;mut Vec&amp;lt;char&amp;gt;) { //let sl = s.</description>
    </item>
    
    <item>
      <title>Rust Note 13</title>
      <link>http://example.org/posts/rustnote13/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote13/</guid>
      <description>整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。
C 解法： class Solution { public: int reverse(int x) { int res=0; while(x){ if(x&amp;gt;0 &amp;amp;&amp;amp; res&amp;gt;(INT_MAX-x%10)/10) return 0; if(x&amp;lt;0 &amp;amp;&amp;amp; res&amp;lt;(INT_MIN-x%10)/10) return 0; res = res*10+x%10; x/=10; } return res; } }; Rust 解法：  impl Solution { pub fn reverse(x: i32) -&amp;gt; i32 { x.abs() .to_string() .chars().rev() .collect::&amp;lt;String&amp;gt;() .parse::&amp;lt;i32&amp;gt;() .</description>
    </item>
    
    <item>
      <title>Rust Note 14</title>
      <link>http://example.org/posts/rustnote14/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote14/</guid>
      <description>字符串中的第一个唯一字符 给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。
C 解法： class Solution { public: int firstUniqChar(string s) { unordered_map&amp;lt;int, int&amp;gt; frequency; for (char ch: s) { ++frequency[ch]; } for (int i = 0; i &amp;lt; s.size(); ++i) { if (frequency[s[i]] == 1) { return i; } } return -1; } }; Rust 解法1： use std::collections::HashMap; impl Solution { pub fn first_uniq_char(s: String) -&amp;gt; i32 { let mut map = HashMap::new(); s.</description>
    </item>
    
    <item>
      <title>Rust Note 15</title>
      <link>http://example.org/posts/rustnote15/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote15/</guid>
      <description>有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
C 解法： class Solution { public boolean isAnagram(String s, String t) { if(s.length() != t.length()) return false; int[] alpha = new int[26]; for(int i = 0; i&amp;lt; s.length(); i++) { alpha[s.charAt(i) - &#39;a&#39;] ++; alpha[t.charAt(i) - &#39;a&#39;] --; } for(int i=0;i&amp;lt;26;i++) if(alpha[i] != 0) return false; return true; } } Rust 解法： impl Solution { pub fn is_anagram(s: String, t: String) -&amp;gt; bool { if s.</description>
    </item>
    
    <item>
      <title>Rust Note 16</title>
      <link>http://example.org/posts/rustnote16/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote16/</guid>
      <description>验证回文串 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。
字母和数字都属于字母数字字符。
给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。
C 解法： class Solution { public: bool isPalindrome(string s) { int n = s.size(); int left = 0, right = n - 1; while (left &amp;lt; right) { while (left &amp;lt; right &amp;amp;&amp;amp; !isalnum(s[left])) { ++left; } while (left &amp;lt; right &amp;amp;&amp;amp; !isalnum(s[right])) { --right; } if (left &amp;lt; right) { if (tolower(s[left]) != tolower(s[right])) { return false; } ++left; --right; } } return true; } }; Rust 解法： impl Solution { pub fn is_palindrome(s: String) -&amp;gt; bool { let s = s .</description>
    </item>
    
    <item>
      <title>Rust Note 17</title>
      <link>http://example.org/posts/rustnote17/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote17/</guid>
      <description>字符串转换整数 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。
函数 myAtoi(string s) 的算法如下：
读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，&amp;ldquo;123&amp;rdquo; -&amp;gt; 123， &amp;ldquo;0032&amp;rdquo; -&amp;gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。 注意：
本题中的空白字符只包括空格字符 &#39; &#39; 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。
C 解法：  // 自动机 class Automaton { string state = &amp;quot;start&amp;quot;; unordered_map&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; table = { {&amp;quot;start&amp;quot;, {&amp;quot;start&amp;quot;, &amp;quot;signed&amp;quot;, &amp;quot;in_number&amp;quot;, &amp;quot;end&amp;quot;}}, {&amp;quot;signed&amp;quot;, {&amp;quot;end&amp;quot;, &amp;quot;end&amp;quot;, &amp;quot;in_number&amp;quot;, &amp;quot;end&amp;quot;}}, {&amp;quot;in_number&amp;quot;, {&amp;quot;end&amp;quot;, &amp;quot;end&amp;quot;, &amp;quot;in_number&amp;quot;, &amp;quot;end&amp;quot;}}, {&amp;quot;end&amp;quot;, {&amp;quot;end&amp;quot;, &amp;quot;end&amp;quot;, &amp;quot;end&amp;quot;, &amp;quot;end&amp;quot;}} }; int get_col(char c) { if (isspace(c)) return 0; if (c == &#39;+&#39; or c == &#39;-&#39;) return 1; if (isdigit(c)) return 2; return 3; } public: int sign = 1; long long ans = 0; void get(char c) { state = table[state][get_col(c)]; if (state == &amp;quot;in_number&amp;quot;) { ans = ans * 10 + c - &#39;0&#39;; ans = sign == 1 ?</description>
    </item>
    
    <item>
      <title>Rust Note 18</title>
      <link>http://example.org/posts/rustnote18/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote18/</guid>
      <description>实现strStr() 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。
C 解法：  // 暴力匹配 class Solution { public: int strStr(string haystack, string needle) { int n = haystack.size(), m = needle.size(); for (int i = 0; i + m &amp;lt;= n; i++) { bool flag = true; for (int j = 0; j &amp;lt; m; j++) { if (haystack[i + j] !</description>
    </item>
    
    <item>
      <title>Rust Note 19</title>
      <link>http://example.org/posts/rustnote19/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote19/</guid>
      <description>外观数列 给定一个正整数 n ，输出外观数列的第 n 项。
「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。
你可以将其视作是由递归公式定义的数字字符串序列：
countAndSay(1) = &amp;ldquo;1&amp;rdquo; countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。 前五项如下：
  1    11    21    1211    111221    第一项是数字 1 描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &amp;ldquo;11&amp;rdquo; 描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &amp;ldquo;21&amp;rdquo; 描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &amp;ldquo;1211&amp;rdquo; 描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &amp;ldquo;111221&amp;rdquo; 要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</description>
    </item>
    
    <item>
      <title>Rust Note 20</title>
      <link>http://example.org/posts/rustnote20/</link>
      <pubDate>Mon, 22 May 2023 20:28:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote20/</guid>
      <description>最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;quot;。
C 解法：  // 先排序，后比较头尾 class Solution { public: string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) { if(strs.empty()) return string(); sort(strs.begin(), strs.end()); string st = strs.front(), en = strs.back(); int i, num = min(st.size(), en.size()); for(i = 0; i &amp;lt; num &amp;amp;&amp;amp; st[i] == en[i]; i ++); return string(st, 0, i); } }; Rust 解法1： impl Solution { pub fn longest_common_prefix(strs: Vec&amp;lt;String&amp;gt;) -&amp;gt; String { let mut x:Vec&amp;lt;_&amp;gt; = strs.iter().map(|c|c.chars()).collect(); let mut res = String::new(); while let Some(t) = x[0].</description>
    </item>
    
    <item>
      <title>Rust Note 10</title>
      <link>http://example.org/posts/rustnote10/</link>
      <pubDate>Fri, 19 May 2023 21:35:55 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote10/</guid>
      <description>有效的数独 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 注意：
一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 空白格用 &amp;lsquo;.&amp;rsquo; 表示。
C 解法： class Solution { public: bool isValidSudoku(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { int row[9][9] = {0}; int col[9][9] = {0}; int box[3][3][9] = {0}; for (int i = 0; i &amp;lt; 9; i++) { for (int j = 0; j &amp;lt; 9; j++) { char c = board[i][j]; if (c == &#39;.</description>
    </item>
    
    <item>
      <title>Rust Note 09</title>
      <link>http://example.org/posts/rustnote09/</link>
      <pubDate>Fri, 19 May 2023 21:35:49 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote09/</guid>
      <description>两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
C 解法： int* twoSum(int* nums, int numsSize, int target, int* returnSize) { for (int i = 0; i &amp;lt; numsSize; ++i) { for (int j = i + 1; j &amp;lt; numsSize; ++j) { if (nums[i] + nums[j] == target) { int* ret = malloc(sizeof(int) * 2); ret[0] = i, ret[1] = j; *returnSize = 2; return ret; } } } *returnSize = 0; return NULL; } Rust 解法： use std::collections::HashMap; impl Solution { pub fn two_sum(nums: Vec&amp;lt;i32&amp;gt;, target: i32) -&amp;gt; Vec&amp;lt;i32&amp;gt; { let mut map = HashMap::new(); for (i,val) in nums.</description>
    </item>
    
    <item>
      <title>Rust Note 08</title>
      <link>http://example.org/posts/rustnote08/</link>
      <pubDate>Fri, 19 May 2023 21:35:46 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote08/</guid>
      <description>移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。
C 解法： class Solution { public void moveZeroes(int[] nums) { int indexNow = 0; int indexNum = 0; int m = nums.length; while(indexNum&amp;lt;m){ if(nums[indexNum] != 0) { nums[indexNow++] = nums[indexNum]; } ++indexNum; } for(int i = indexNow; i &amp;lt; m; i++){ nums[i] = 0; } } } Rust 解法： impl Solution { pub fn move_zeroes(nums: &amp;amp;mut Vec&amp;lt;i32&amp;gt;) { let len = nums.len(); nums.retain(|x| *x !</description>
    </item>
    
    <item>
      <title>Rust Note 07</title>
      <link>http://example.org/posts/rustnote07/</link>
      <pubDate>Fri, 19 May 2023 21:35:43 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote07/</guid>
      <description>加一 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。
C 解法： int* plusOne(int* digits, int digitsSize, int* returnSize){ for(int i = digitsSize - 1; i &amp;gt;= 0; --i){ digits[i] = digits[i] + 1;//最后元素+1判断是不是10 //如果当前元素不为10，直接返回数组 if(digits[i] != 10){ *returnSize = digitsSize; return digits; } //第一个元素不为10，后面元素均为10的情况 if(digits[i] == 10) digits[i] = 0; } //元素全为9开辟新数组 int* ans = malloc(sizeof(int) * (digitsSize + 1)); memset(ans, 0, sizeof(int) * (digitsSize + 1));//全部置0 ans[0] = 1; *returnSize = digitsSize + 1; return ans; } Rust 解法： impl Solution { pub fn plus_one(digits: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; { match digits.</description>
    </item>
    
    <item>
      <title>Rust Note 06</title>
      <link>http://example.org/posts/rustnote06/</link>
      <pubDate>Fri, 19 May 2023 21:35:39 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote06/</guid>
      <description>两个数组的交集 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。
C解法 ： int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) { int* rearr = (int*)malloc(sizeof(int)*(nums1Size&amp;gt;nums2Size?nums2Size:nums1Size)); int a[1001] = {0}; int b[1001] = {0}; for(int i = 0; i&amp;lt;nums1Size; i++) { a[nums1[i]]++; } for(int i = 0; i&amp;lt;nums2Size; i++) { b[nums2[i]]++; } *returnSize = 0; for(int i = 0; i&amp;lt;1001; i++) { if(a[i]&amp;gt;0&amp;amp;&amp;amp;b[i]&amp;gt;0) { int n = (a[i]&amp;gt;b[i])?b[i]:a[i]; for(int j = 0; j&amp;lt;n ;j++) { rearr[*returnSize] = i; (*returnSize)++; } } } return rearr; } Rust 解法 ： use std::collections::HashMap; impl Solution { pub fn intersect(nums1: Vec&amp;lt;i32&amp;gt;, nums2: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;i32&amp;gt; { let mut ans = vec!</description>
    </item>
    
    <item>
      <title>Rust Note 05</title>
      <link>http://example.org/posts/rustnote05/</link>
      <pubDate>Fri, 19 May 2023 21:35:34 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote05/</guid>
      <description>只出现一次的数字 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
C解法 ： int singleNumber(int* nums, int numsSize){ int a = 0; for (int i = 0; i &amp;lt; numsSize; i++) { a = a ^ nums[i]; } return a; } Rust 解法 ： impl Solution { pub fn single_number(nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { nums.iter().fold(0,|acc,x| acc^x) } } Rust fold() 函数 ： fn fold&amp;lt;B, F&amp;gt;(self, init: B, f: F) -&amp;gt; B where
F: FnMut(B, Self::Item) -&amp;gt; B, 通过应用操作将每个元素 fold 到一个累加器中，返回最终结果。</description>
    </item>
    
    <item>
      <title>Rust Note 04</title>
      <link>http://example.org/posts/rustnote04/</link>
      <pubDate>Fri, 19 May 2023 21:35:29 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote04/</guid>
      <description>存在重复元素 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。
C 解法 ： public boolean containsDuplicate(int[] nums) { Arrays.sort(nums); for (int ind = 1; ind &amp;lt; nums.length; ind++) { if (nums[ind] == nums[ind - 1]) { return true; } } return false; } Rust 解法 1 : impl Solution { pub fn contains_duplicate(mut nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; bool { nums.sort(); (&amp;amp;nums).windows(2).fold(false, |mut res,y|{ (y[0] == y[1]) | res }) } } Rust 解法 2 ： impl Solution { pub fn contains_duplicate(nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; bool { let mut vec = nums.</description>
    </item>
    
    <item>
      <title>Rust Note 03</title>
      <link>http://example.org/posts/rustnote03/</link>
      <pubDate>Fri, 19 May 2023 20:33:16 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote03/</guid>
      <description>买卖股票的最佳时机2 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
返回 你能获得的 最大 利润 。
C 解法 ： public int maxProfit(int[] prices) { if (prices == null || prices.length &amp;lt; 2) return 0; int total = 0, index = 0, length = prices.length; while (index &amp;lt; length) { //如果股票下跌就一直找，直到找到股票开始上涨为止 while (index &amp;lt; length - 1 &amp;amp;&amp;amp; prices[index] &amp;gt;= prices[index + 1]) index++; //股票上涨开始的值，也就是这段时间上涨的最小值 int min = prices[index]; //一直找到股票上涨的最大值为止 while (index &amp;lt; length - 1 &amp;amp;&amp;amp; prices[index] &amp;lt;= prices[index + 1]) index++; //计算这段上涨时间的差值，然后累加 total += prices[index++] - min; } return total; } Rust 解法1 ： impl Solution { pub fn max_profit(prices: Vec&amp;lt;i32&amp;gt;) -&amp;gt; i32 { let mut profit = 0; for i in 1.</description>
    </item>
    
    <item>
      <title>Rust Note 01</title>
      <link>http://example.org/posts/rustnote01/</link>
      <pubDate>Thu, 18 May 2023 19:58:49 +0800</pubDate>
      
      <guid>http://example.org/posts/rustnote01/</guid>
      <description>删除排序数组中的重复项 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。
考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：
更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。
C 解法： //双指针解决 public int removeDuplicates(int[] A) { //边界条件判断 if (A == null || A.length == 0) return 0; int left = 0; for (int right = 1; right &amp;lt; A.length; right++) //如果左指针和右指针指向的值一样，说明有重复的， //这个时候，左指针不动，右指针继续往右移。如果他俩 //指向的值不一样就把右指针指向的值往前挪 if (A[left] !</description>
    </item>
    
    <item>
      <title>博文总述</title>
      <link>http://example.org/posts/my-first-post/</link>
      <pubDate>Thu, 18 May 2023 17:06:05 +0800</pubDate>
      
      <guid>http://example.org/posts/my-first-post/</guid>
      <description>博文总述
标签：  - rust - leetcode初级算法篇 leetcode算法类型： - 拒绝采样 - 数组 - 字符串 - 哈希表 - 动态规划  </description>
    </item>
    
  </channel>
</rss>
