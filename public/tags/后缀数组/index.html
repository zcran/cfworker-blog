<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>后缀数组 | Paperubit的博客</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.113.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
      <link href="/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/index.xml" rel="alternate" type="application/rss+xml" title="Paperubit的博客" />
      <link href="/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/index.xml" rel="feed" type="application/rss+xml" title="Paperubit的博客" />
      
    
    
    <meta property="og:title" content="后缀数组" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://example.org/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" />
<meta itemprop="name" content="后缀数组">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="后缀数组"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Paperubit的博客
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          后缀数组
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="cf pa3 pa4-m pa4-l">
    <div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links mid-gray">
      <p>Below you will find pages that utilize the taxonomy term “后缀数组”</p>
    </div>
  </article>
  <div class="mw8 center">
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%841/" class="link black dim">
        Leetcode 后缀数组1
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      构造字符串的总得分和 你需要从空字符串开始 构造 一个长度为 n 的字符串 s ，构造的过程为每次给当前字符串 前面 添加 一个 字符。构造过程中得到的所有字符串编号为 1 到 n ，其中长度为 i 的字符串编号为 si 。
比方说，s = &ldquo;abaca&rdquo; ，s1 == &ldquo;a&rdquo; ，s2 == &ldquo;ca&rdquo; ，s3 == &ldquo;aca&rdquo; 依次类推。 si 的 得分 为 si 和 sn 的 最长公共前缀 的长度（注意 s == sn ）。
给你最终的字符串 s ，请你返回每一个 si 的 得分之和 。
class Solution { public: long long sumScores(string s) { int n = s.length(); long ans = n; vector&lt;int&gt; z(n); for (int i = 1, l = 0, r = 0; i &lt; n; ++i) { z[i] = max(min(z[i - l], r - i + 1), 0); while (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) { l = i; r = i + z[i]; ++z[i]; } ans += z[i]; } return ans; } }; 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%842/" class="link black dim">
        Leetcode 后缀数组2
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      划分数字的方案数 你写下了若干 正整数 ，并将它们连接成了一个字符串 num 。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 非递减 的且 没有 任何数字有前导 0 。
请你返回有多少种可能的 正整数数组 可以得到字符串 num 。由于答案可能很大，将结果对 10^9 + 7 取余 后返回。
impl Solution { pub fn number_of_combinations(num: String) -&gt; i32 { if num.chars().nth(0) == Some(&#39;0&#39;) {return 0;} let n = num.len(); let mut ord = vec![vec![0;n + 1];n]; for i in 0..n { ord[i][1] = (num.chars().nth(i).unwrap() as u8 - &#39;0&#39; as u8) as usize; } let mut nr_ord = 10; for l in 2.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%843/" class="link black dim">
        Leetcode 后缀数组3
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      最长公共子路径 一个国家由 n 个编号为 0 到 n - 1 的城市组成。在这个国家里，每两个 城市之间都有一条道路连接。
总共有 m 个编号为 0 到 m - 1 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 重复 出现，但同一个城市在一条路径中不会连续出现。
给你一个整数 n 和二维数组 paths ，其中 paths[i] 是一个整数数组，表示第 i 个朋友走过的路径，请你返回 每一个 朋友都走过的 最长公共子路径 的长度，如果不存在公共子路径，请你返回 0 。
一个 子路径 指的是一条路径中连续的城市序列。
fn sa_is(s: &amp;[usize], upper: usize) -&gt; Vec&lt;usize&gt; { let n = s.len(); match n { 0 =&gt; return vec![], 1 =&gt; return vec![0], 2 =&gt; return if s[0] &lt; s[1] { vec!
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%844/" class="link black dim">
        Leetcode 后缀数组4
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      最长重复子串 给你一个字符串 s ，考虑其所有 重复子串 ：即 s 的（连续）子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。
返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 &quot;&quot; 。
impl Solution { // tp已经排好，开始排序第一关键字 fn sort(sa: &amp;mut Vec&lt;usize&gt;, rank: &amp;mut Vec&lt;usize&gt;, tp: &amp;Vec&lt;usize&gt;, n: usize, m: usize) { let mut tax = vec![0; m+1]; // 第一关键字基数排序 rank[1..].iter().for_each(|x| tax[*x] += 1); // 前缀和，为了后面方便计算第几名 for i in 1..=m { tax[i] += tax[i-1]; } tp[1..].iter().rev().for_each(|&amp;key| { // 拿最小的第二关键字对应的后缀key_2，然后通过rank找到他对应的第一关键字所处的level(第一关键字排名) let level = rank[key]; // tax[level]就表示在这里level之下一共有j个数，则后缀(tp[i])排名第j // 此时放的是第一关键字相同，第二关键字最大 // rank其实也是排好的，拿的是前w/2的rank let j = tax[level]; sa[j] = key; tax[level] -= 1; }); } fn init(s: &amp;str, n: usize, m: usize) -&gt; (Vec&lt;usize&gt;, Vec&lt;usize&gt;, Vec&lt;usize&gt;) { // 只有第一关键字直接映射就好 let mut rank = vec!
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/my-first-post/" class="link black dim">
        博文总述
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      博文总述
标签： - rust - leetcode初级算法篇 leetcode算法类型： 见下方超链接类别 
    </div>
  </div>
</div>

        </div>
      
    </section>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  Paperubit的博客 2023 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
