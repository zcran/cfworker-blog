<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Shell | Paperubit的博客</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.113.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
      <link href="/tags/shell/index.xml" rel="alternate" type="application/rss+xml" title="Paperubit的博客" />
      <link href="/tags/shell/index.xml" rel="feed" type="application/rss+xml" title="Paperubit的博客" />
      
    
    
    <meta property="og:title" content="Shell" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://example.org/tags/shell/" />
<meta itemprop="name" content="Shell">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Shell"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Paperubit的博客
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Shell
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="cf pa3 pa4-m pa4-l">
    <div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links mid-gray">
      <p>Below you will find pages that utilize the taxonomy term “Shell”</p>
    </div>
  </article>
  <div class="mw8 center">
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-shell1/" class="link black dim">
        Leetcode Shell1
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      第十行 给定一个文本文件 file.txt，请只打印这个文件中的第十行。
sed -n &#39;10p&#39; file.txt 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-shell2/" class="link black dim">
        Leetcode Shell2
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      统计词频 写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。
为了简单起见，你可以假设：
words.txt只包括小写字母和 &rsquo; &rsquo; 。 每个单词只由小写字母组成。 单词间由一个或多个空格字符分隔。 示例:
假设 words.txt 内容如下：
the day is sunny the the the sunny is is 你的脚本应当输出（以词频降序排列）：
the 4 is 3 sunny 2 day 1 说明:
不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。 你可以使用一行 Unix pipes 实现吗？
cat words.txt | tr -s &#39; &#39; &#39;\n&#39;|sort|uniq -c |sort -r|awk &#39;{print $2&#34; &#34;$1}&#39; cat ——浏览文件 tr -s ——替换字符串（空格换为换行）保证了一行一个单词 sort ——默认ASCII值排序，排序号后还会有重复 uniq —— 去重，-c再输出重复次数。结果就是 ”4 abc“ abc出现了4次 sort -r —— 反向排序，也就是从大到小。得到按频率高低的结果 awk ——格式化输出，规定输出是先字符串再重复次数，所以先$2再$1，中间空格分隔 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-shell3/" class="link black dim">
        Leetcode Shell3
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      有效电话号码 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。
你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）
你也可以假设每行前后没有多余的空格字符。
// 三种方法 grep -P &#39;^(\d{3}-|\(\d{3}\) )\d{3}-\d{4}$&#39; file.txt sed -n -r &#39;/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/p&#39; file.txt awk &#39;/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-([0-9]{4})$/&#39; file.txt 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-shell4/" class="link black dim">
        Leetcode Shell4
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转置文件 给定一个文件 file.txt，转置它的内容。
你可以假设每行列数相同，并且每个字段由 &rsquo; &rsquo; 分隔。
# Read from the file file.txt and print its transposed content to stdout. awk &#39;{ #这个大括号里的代码是 对正文的处理 # NF表示列数，NR表示已读的行数 # 注意for中的i从1开始，i前没有类型 for (i=1; i&lt;=NF; i++){#对每一列 if(NR==1){ #如果是第一行 #将第i列的值存入res[i],$i表示第i列的值，i为数组的下标，以列序号为下标， #数组不用定义可以直接使用 res[i]=$i; } else{ #不是第一行时，将该行对应i列的值拼接到res[i] res[i]=res[i] &#34; &#34; $i } } } # BEGIN{} 文件进行扫描前要执行的操作；END{} 文件扫描结束后要执行的操作。 END{ #输出数组 for (i=1; i&lt;=NF; i++){ print res[i] } }&#39; file.txt 
    </div>
  </div>
</div>

        </div>
      
    </section>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  Paperubit的博客 2023 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
