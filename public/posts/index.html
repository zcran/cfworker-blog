<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Paperubit的博客</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.113.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
      <link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="Paperubit的博客" />
      <link href="/posts/index.xml" rel="feed" type="application/rss+xml" title="Paperubit的博客" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://example.org/posts/" />
<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Paperubit的博客
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A91/" class="link black dim">
        Leetcode 快速选择1
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      摆动排序 II 给你一个整数数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]&hellip; 的顺序。
你可以假设所有输入数组都可以得到满足题目要求的结果。
impl Solution { pub fn wiggle_sort(nums: &amp;mut Vec&lt;i32&gt;) { let mut nums_copy = nums.clone(); nums_copy.sort(); let n = nums.len(); let (mut p, mut q) = ((n - 1) / 2, n - 1); for i in 0..n { if (i &amp; 1) == 1 { nums[i] = nums_copy[q]; q -= 1; } else { nums[i] = nums_copy[p]; p -= 1; }; } } } 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A92/" class="link black dim">
        Leetcode 快速选择2
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      数组中的第K个最大元素 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
use std::collections::BinaryHeap; impl Solution { pub fn find_kth_largest(nums: Vec&lt;i32&gt;, k: i32) -&gt; i32 { let mut h = BinaryHeap::from(nums.iter().map(|&amp;i| -i).take(k as usize).collect::&lt;Vec&lt;_&gt;&gt;()); for i in k as usize..nums.len() { h.push(-nums[i]); h.pop(); } -h.peek().unwrap() } } 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A93/" class="link black dim">
        Leetcode 快速选择3
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      找出第 K 大的异或坐标值 给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。
矩阵中坐标 (a, b) 的 值 可由对所有满足 0 &lt;= i &lt;= a &lt; m 且 0 &lt;= j &lt;= b &lt; n 的元素 matrix[i][j]（下标从 0 开始计数）执行异或运算得到。
请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。
impl Solution { pub fn kth_largest_value(mut matrix: Vec&lt;Vec&lt;i32&gt;&gt;, k: i32) -&gt; i32 { for row in 0..matrix.len() { let mut sum = 0; for col in 0.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A94/" class="link black dim">
        Leetcode 快速选择4
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      找出数组中的第 K 大整数 给你一个字符串数组 nums 和一个整数 k 。nums 中的每个字符串都表示一个不含前导零的整数。
返回 nums 中表示第 k 大整数的字符串。
注意：重复的数字在统计时会视为不同元素考虑。例如，如果 nums 是 [&ldquo;1&rdquo;,&ldquo;2&rdquo;,&ldquo;2&rdquo;]，那么 &ldquo;2&rdquo; 是最大的整数，&ldquo;2&rdquo; 是第二大的整数，&ldquo;1&rdquo; 是第三大的整数。
impl Solution { pub fn kth_largest_number(mut nums: Vec&lt;String&gt;, k: i32) -&gt; String { // 自定义比较函数，在 a 对应的整数较大时返回 true，反之返回 false nums.sort_by(|a, b| { // 首先比较字符串长度 if a.len() &gt; b.len() { return std::cmp::Ordering::Greater; } else if a.len() &lt; b.len() { return std::cmp::Ordering::Less; } else { // 长度相等时比较字符串字典序大小 a.cmp(&amp;b) } }); nums[nums.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A95/" class="link black dim">
        Leetcode 快速选择5
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      最接近原点的 K 个点 给定一个数组 points ，其中 points[i] = [x⌄i, y⌄i] 表示 X-Y 平面上的一个点，并且是一个整数 k ，返回离原点 (0,0) 最近的 k 个点。
这里，平面上两点之间的距离是 欧几里德距离（ √(x⌄1 - x⌄2)2 + (y⌄1 - y⌄2)2 ）。
你可以按 任何顺序 返回答案。除了点坐标的顺序之外，答案 确保 是 唯一 的。
impl Solution { pub fn k_closest(points: Vec&lt;Vec&lt;i32&gt;&gt;, k: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; { let mut ans = points; ans.sort_unstable_by_key(|a| a[0] * a[0] + a[1] * a[1]); ans.truncate(k as usize); // 保留第一个 k 元素，然后丢弃其余的元素 ans } } 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A96/" class="link black dim">
        Leetcode 快速选择6
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      最小K个数 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
示例：
输入： arr = [1,3,5,7,2,4,6,8], k = 4 输出： [1,2,3,4] 提示：
0 &lt;= len(arr) &lt;= 100000 0 &lt;= k &lt;= min(100000, len(arr))
impl Solution { pub fn get_least_numbers(arr: Vec&lt;i32&gt;, k: i32) -&gt; Vec&lt;i32&gt; { let mut arr = arr; arr.sort(); arr[..k as usize].iter().cloned().collect() } } 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E8%BF%AD%E4%BB%A3%E5%99%A81/" class="link black dim">
        Leetcode 迭代器1
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      二叉搜索树迭代器 实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器： BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。 boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。 int next()将指针向右移动，然后返回指针处的数字。 注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。
你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。
struct BSTIterator { stack: Vec&lt;Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;&gt;, } use std::cell::RefCell; use std::rc::Rc; impl BSTIterator { fn new(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Self { BSTIterator { stack: vec![root] } } fn next(&amp;mut self) -&gt; i32 { let mut node = self.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E8%BF%AD%E4%BB%A3%E5%99%A82/" class="link black dim">
        Leetcode 迭代器2
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      扁平化嵌套列表迭代器 给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。
实现扁平迭代器类 NestedIterator ：
NestedIterator(List nestedList) 用嵌套列表 nestedList 初始化迭代器。 int next() 返回嵌套列表的下一个整数。 boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。 你的代码将会用下述伪代码检测：
initialize iterator with nestedList res = [] while iterator.hasNext() append iterator.next() to the end of res return res 如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。
struct NestedIterator(Vec&lt;i32&gt;); impl NestedIterator { fn new(nestedList: Vec&lt;NestedInteger&gt;) -&gt; Self { let mut v=collect(nestedList); v.reverse(); Self(v) } #[inline(always)] fn next(&amp;mut self) -&gt; i32 { self.0.pop().unwrap() } #[inline(always)] fn has_next(&amp;self) -&gt; bool { self.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E8%BF%AD%E4%BB%A3%E5%99%A83/" class="link black dim">
        Leetcode 迭代器3
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      RLE 迭代器 我们可以使用游程编码(即 RLE )来编码一个整数序列。在偶数长度 encoding ( 从 0 开始 )的游程编码数组中，对于所有偶数 i ，encoding[i] 告诉我们非负整数 encoding[i + 1] 在序列中重复的次数。
例如，序列 arr = [8,8,8,5,5] 可以被编码为 encoding =[3,8,2,5] 。encoding =[3,8,0,9,2,5] 和 encoding =[2,8,1,8,2,5] 也是 arr 有效的 RLE 。 给定一个游程长度的编码数组，设计一个迭代器来遍历它。
实现 RLEIterator 类:
RLEIterator(int[] encoded) 用编码后的数组初始化对象。 int next(int n) 以这种方式耗尽后 n 个元素并返回最后一个耗尽的元素。如果没有剩余的元素要耗尽，则返回 -1 。
struct RLEIterator { iterator: std::vec::IntoIter&lt;i32&gt;, remain: (i32, i32), } /** * `&amp;self` means the method takes an immutable reference. * If you need a mutable reference, change it to `&amp;mut self` instead.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E8%BF%AD%E4%BB%A3%E5%99%A84/" class="link black dim">
        Leetcode 迭代器4
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      字母组合迭代器 请你设计一个迭代器类 CombinationIterator ，包括以下内容：
CombinationIterator(string characters, int combinationLength) 一个构造函数，输入参数包括：用一个 有序且字符唯一 的字符串 characters（该字符串只包含小写英文字母）和一个数字 combinationLength 。 函数 next() ，按 字典序 返回长度为 combinationLength 的下一个字母组合。 函数 hasNext() ，只有存在长度为 combinationLength 的下一个字母组合时，才返回 true
struct CombinationIterator { s: Vec&lt;u8&gt;, pos: Vec&lt;usize&gt;, has_next: bool, } impl CombinationIterator { fn new(characters: String, len: i32) -&gt; Self { let mut s = characters.into_bytes(); s.sort_unstable(); Self { s, pos: (0..len as usize).collect(), has_next: true, } } fn next(&amp;mut self) -&gt; String { fn dfs(pos: &amp;mut Vec&lt;usize&gt;, cur: usize, len: usize, has_next: &amp;mut bool) -&gt; usize { let i = pos.
    </div>
  </div>
</div>

        </div>
      
    </section>
    <ul class="pagination pagination-default">
      <li class="page-item disabled">
        <a aria-disabled="true" aria-label="First" class="page-link" role="button" tabindex="-1"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item disabled">
        <a aria-disabled="true" aria-label="Previous" class="page-link" role="button" tabindex="-1"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 1" class="page-link" role="button">1</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/2/" aria-label="Page 2" class="page-link" role="button">2</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/3/" aria-label="Page 3" class="page-link" role="button">3</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/4/" aria-label="Page 4" class="page-link" role="button">4</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/5/" aria-label="Page 5" class="page-link" role="button">5</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/2/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/11/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  Paperubit的博客 2023 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
