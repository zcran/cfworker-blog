<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Rust Note 05 | Paperubit的博客</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="只出现一次的数字 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
C解法 ： int singleNumber(int* nums, int numsSize){ int a = 0; for (int i = 0; i &lt; numsSize; i&#43;&#43;) { a = a ^ nums[i]; } return a; } Rust 解法 ： impl Solution { pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; i32 { nums.iter().fold(0,|acc,x| acc^x) } } Rust fold() 函数 ： fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B where
F: FnMut(B, Self::Item) -&gt; B, 通过应用操作将每个元素 fold 到一个累加器中，返回最终结果。">
    <meta name="generator" content="Hugo 0.91.2" />
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="Rust Note 05" />
<meta property="og:description" content="只出现一次的数字 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
C解法 ： int singleNumber(int* nums, int numsSize){ int a = 0; for (int i = 0; i &lt; numsSize; i&#43;&#43;) { a = a ^ nums[i]; } return a; } Rust 解法 ： impl Solution { pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; i32 { nums.iter().fold(0,|acc,x| acc^x) } } Rust fold() 函数 ： fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B where
F: FnMut(B, Self::Item) -&gt; B, 通过应用操作将每个元素 fold 到一个累加器中，返回最终结果。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/rustnote05/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-19T21:35:34+08:00" />
<meta property="article:modified_time" content="2023-05-19T21:35:34+08:00" />

<meta itemprop="name" content="Rust Note 05">
<meta itemprop="description" content="只出现一次的数字 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
C解法 ： int singleNumber(int* nums, int numsSize){ int a = 0; for (int i = 0; i &lt; numsSize; i&#43;&#43;) { a = a ^ nums[i]; } return a; } Rust 解法 ： impl Solution { pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; i32 { nums.iter().fold(0,|acc,x| acc^x) } } Rust fold() 函数 ： fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B where
F: FnMut(B, Self::Item) -&gt; B, 通过应用操作将每个元素 fold 到一个累加器中，返回最终结果。"><meta itemprop="datePublished" content="2023-05-19T21:35:34+08:00" />
<meta itemprop="dateModified" content="2023-05-19T21:35:34+08:00" />
<meta itemprop="wordCount" content="299">
<meta itemprop="keywords" content="rust,leetcode,初级算法篇," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust Note 05"/>
<meta name="twitter:description" content="只出现一次的数字 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
C解法 ： int singleNumber(int* nums, int numsSize){ int a = 0; for (int i = 0; i &lt; numsSize; i&#43;&#43;) { a = a ^ nums[i]; } return a; } Rust 解法 ： impl Solution { pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; i32 { nums.iter().fold(0,|acc,x| acc^x) } } Rust fold() 函数 ： fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B where
F: FnMut(B, Self::Item) -&gt; B, 通过应用操作将每个元素 fold 到一个累加器中，返回最终结果。"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Paperubit的博客
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Rust Note 05</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2023-05-19T21:35:34+08:00">May 19, 2023</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h2 id="只出现一次的数字">只出现一次的数字</h2>
<p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<h2 id="c解法-">C解法 ：</h2>
<pre tabindex="0"><code>int singleNumber(int* nums, int numsSize){
    int a = 0;
    for (int i = 0; i &lt; numsSize; i++)
    {
        a = a ^ nums[i];
    }
    return a;
}
</code></pre><h2 id="rust-解法-">Rust 解法 ：</h2>
<pre tabindex="0"><code>impl Solution {
    pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; i32 {
    nums.iter().fold(0,|acc,x| acc^x)
    }
}
</code></pre><h2 id="rust-fold-函数-">Rust fold() 函数 ：</h2>
<p>fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B where<br>
    F: FnMut(B, Self::Item) -&gt; B, </p>
<p>通过应用操作将每个元素 <code>fold</code> 到一个累加器中，返回最终结果。</p>
<p><code>fold()</code> 有两个参数：一个初始值，一个闭包，有两个参数：一个 ‘accumulator’ 和一个元素。 闭包返回累加器在下一次迭代中应具有的值。</p>
<p>初始值是累加器在第一次调用时将具有的值。</p>
<p>在将此闭包应用于迭代器的每个元素之后，<code>fold()</code> 返回累加器。</p>
<p>该操作有时称为 ‘reduce’ 或 ‘inject’。</p>
<p>当您拥有某个集合，并且希望从中产生单个值时，<code>fold</code> 非常有用。</p>
<p>Note: <code>fold()</code> 和遍历整个迭代器的类似方法可能不会因无限迭代器而终止，即使在 traits 上，其结果在有限时间内是可确定的。</p>
<p>Note: 如果累加器类型和项类型相同，则可以使用 <code>reduce()</code>将第一个元素用作初始值。</p>
<p>Note: <code>fold()</code> 以<em>左关联</em>方式组合元素。 对于像 <code>+</code> 这样的关联性，元素组合的顺序并不重要，但对于像 <code>-</code> 这样的非关联性，顺序会影响最终结果。 对于 <code>fold()</code> 的<em>右关联</em>版本，请参见 <code>DoubleEndedIterator::rfold()</code>。</p>
<p>就此而言，其他几种 (forward) 方法都具有默认实现，因此，如果它可以做得比默认 <code>for</code> 循环实现更好，请尝试显式实现此方法。</p>
<p>特别是，请尝试将此 <code>fold()</code> 放在组成此迭代器的内部部件上。</p>
<p>基本用法：</p>
<pre tabindex="0"><code>let a = [1, 2, 3];

// 数组所有元素的总和
let sum = a.iter().fold(0, |acc, x| acc + x);

assert_eq!(sum, 6);
</code></pre><p>让我们在这里遍历迭代的每个步骤：</p>
<table>
<thead>
<tr>
<th>element</th>
<th>acc</th>
<th>x</th>
<th>result</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>3</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>所以，我们的最终结果，<code>6</code>。</p>
<p>这个例子演示了 <code>fold()</code> 的左关联特性： 它构建一个字符串，从一个初始值开始，从前面到后面的每个元素继续：</p>
<pre tabindex="0"><code>let numbers = [1, 2, 3, 4, 5];

let zero = &quot;0&quot;.to_string();

let result = numbers.iter().fold(zero, |acc, &amp;x| {
    format!(&quot;({} + {})&quot;, acc, x)
});

assert_eq!(result, &quot;(((((0 + 1) + 2) + 3) + 4) + 5)&quot;);
</code></pre><p>对于那些不经常使用迭代器的人，通常会使用 <code>for</code> 循环并附带一系列要建立结果的列表。那些可以变成 <code>fold ()</code> s：</p>
<pre tabindex="0"><code>let numbers = [1, 2, 3, 4, 5];

let mut result = 0;

// for 循环：
for i in &amp;numbers {
    result = result + i;
}

// fold:
let result2 = numbers.iter().fold(0, |acc, &amp;x| acc + x);

// 他们是一样的
assert_eq!(result, result2);
</code></pre><h4 id="source-">source :</h4>
<pre tabindex="0"><code>#[doc(alias = &quot;inject&quot;, alias = &quot;foldl&quot;)]
#[inline]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
fn fold&lt;B, F&gt;(mut self, init: B, mut f: F) -&gt; B
where
    Self: Sized,
    F: FnMut(B, Self::Item) -&gt; B,
{
    let mut accum = init;
    while let Some(x) = self.next() {
        accum = f(accum, x);
    }
    accum
}
</code></pre><ul class="pa0">
  
   <li class="list di">
     <a href="/tags/rust/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">rust</a>
   </li>
  
   <li class="list di">
     <a href="/tags/leetcode/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">leetcode</a>
   </li>
  
   <li class="list di">
     <a href="/tags/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E7%AF%87/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">初级算法篇</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/posts/rustnote04/">Rust Note 04</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/rustnote03/">Rust Note 03</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/rustnote01/">Rust Note 01</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/my-first-post/">博文总述</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/rustnote02/">Rust Note 02</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  Paperubit的博客 2023 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
