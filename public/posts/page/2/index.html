<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Paperubit的博客</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.113.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
      <link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="Paperubit的博客" />
      <link href="/posts/index.xml" rel="feed" type="application/rss+xml" title="Paperubit的博客" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://example.org/posts/" />
<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Paperubit的博客
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A14/" class="link black dim">
        Leetcode 概率与统计4
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      新 21 点 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
爱丽丝以 0 分开始，并在她的得分少于 k 分时抽取数字。 抽取时，她从 [1, maxPts] 的范围中随机获得一个整数作为分数进行累计，其中 maxPts 是一个整数。 每次抽取都是独立的，其结果具有相同的概率。
当爱丽丝获得 k 分 或更多分 时，她就停止抽取数字。
爱丽丝的分数不超过 n 的概率是多少？
与实际答案误差不超过 10-5 的答案将被视为正确答案。
示例 1：
输入：n = 10, k = 1, maxPts = 10 输出：1.00000 解释：爱丽丝得到一张牌，然后停止。 示例 2：
输入：n = 6, k = 1, maxPts = 10 输出：0.60000 解释：爱丽丝得到一张牌，然后停止。 在 10 种可能性中的 6 种情况下，她的得分不超过 6 分。 示例 3：
输入：n = 21, k = 17, maxPts = 10 输出：0.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A15/" class="link black dim">
        Leetcode 概率与统计5
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      N个骰子的点数 你选择掷出 num 个色子，请返回所有点数总和的概率。
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 num 个骰子所能掷出的点数集合中第 i 小的那个的概率。
impl Solution { pub fn dices_probability(n: i32) -&gt; Vec&lt;f64&gt; { let mut ans = vec![1.0 / 6.0].repeat(6); for i in 2..=n as usize { let mut tmp = vec![0.0; 5 * i + 1]; for j in 0..6 { for k in 0..ans.len() { tmp[k + j] += ans[k] / 6.0; } } ans = tmp; } ans } } 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A11/" class="link black dim">
        Leetcode 概率与统计1
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      飞机座位分配概率 有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。
剩下的乘客将会：
如果他们自己的座位还空着，就坐到自己的座位上，
当他们自己的座位被占用时，随机选择其他座位 第 n 位乘客坐在自己的座位上的概率是多少？
impl Solution { pub fn nth_person_gets_nth_seat(n: i32) -&gt; f64 { if n &lt;= 2 { return 1.0 / n as f64 } let mut prob = 0.5; for i in 3..=n { prob = (1.0 + (i - 2) as f64 * prob) / i as f64; } prob } } 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A12/" class="link black dim">
        Leetcode 概率与统计2
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      分汤 有 A 和 B 两种类型 的汤。一开始每种类型的汤有 n 毫升。有四种分配操作：
提供 100ml 的 汤A 和 0ml 的 汤B 。 提供 75ml 的 汤A 和 25ml 的 汤B 。 提供 50ml 的 汤A 和 50ml 的 汤B 。 提供 25ml 的 汤A 和 75ml 的 汤B 。 当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。
注意 不存在先分配 100 ml 汤B 的操作。
需要返回的值： 汤A 先分配完的概率 + 汤A和汤B 同时分配完的概率 / 2。返回值在正确答案 10-5 的范围内将被认为是正确的。
impl Solution { pub fn soup_servings(n: i32) -&gt; f64 { fn recursive(dp: &amp;mut Vec&lt;Vec&lt;f64&gt;&gt;, a: i32, b: i32) -&gt; f64 { if a &lt;= 0 &amp;&amp; b &lt;= 0 { return 0.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A13/" class="link black dim">
        Leetcode 概率与统计3
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      期望个数统计 某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。
小 A 和小 B 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中等可能地取一个。现在给定 n 名面试者的能力值 scores，设 X 代表小 A 和小 B 的浏览顺序中出现在同一位置的简历数，求 X 的期望。
提示：离散的非负随机变量的期望计算公式为。在本题中，由于 X 的取值为 0 到 n 之间，期望计算公式可以是。
impl Solution { pub fn expect_number(scores: Vec&lt;i32&gt;) -&gt; i32 { scores.into_iter().collect::&lt;std::collections::HashSet&lt;i32&gt;&gt;().len() as i32 } } 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%841/" class="link black dim">
        Leetcode 后缀数组1
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      构造字符串的总得分和 你需要从空字符串开始 构造 一个长度为 n 的字符串 s ，构造的过程为每次给当前字符串 前面 添加 一个 字符。构造过程中得到的所有字符串编号为 1 到 n ，其中长度为 i 的字符串编号为 si 。
比方说，s = &ldquo;abaca&rdquo; ，s1 == &ldquo;a&rdquo; ，s2 == &ldquo;ca&rdquo; ，s3 == &ldquo;aca&rdquo; 依次类推。 si 的 得分 为 si 和 sn 的 最长公共前缀 的长度（注意 s == sn ）。
给你最终的字符串 s ，请你返回每一个 si 的 得分之和 。
class Solution { public: long long sumScores(string s) { int n = s.length(); long ans = n; vector&lt;int&gt; z(n); for (int i = 1, l = 0, r = 0; i &lt; n; ++i) { z[i] = max(min(z[i - l], r - i + 1), 0); while (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) { l = i; r = i + z[i]; ++z[i]; } ans += z[i]; } return ans; } }; 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%842/" class="link black dim">
        Leetcode 后缀数组2
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      划分数字的方案数 你写下了若干 正整数 ，并将它们连接成了一个字符串 num 。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 非递减 的且 没有 任何数字有前导 0 。
请你返回有多少种可能的 正整数数组 可以得到字符串 num 。由于答案可能很大，将结果对 10^9 + 7 取余 后返回。
impl Solution { pub fn number_of_combinations(num: String) -&gt; i32 { if num.chars().nth(0) == Some(&#39;0&#39;) {return 0;} let n = num.len(); let mut ord = vec![vec![0;n + 1];n]; for i in 0..n { ord[i][1] = (num.chars().nth(i).unwrap() as u8 - &#39;0&#39; as u8) as usize; } let mut nr_ord = 10; for l in 2.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%843/" class="link black dim">
        Leetcode 后缀数组3
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      最长公共子路径 一个国家由 n 个编号为 0 到 n - 1 的城市组成。在这个国家里，每两个 城市之间都有一条道路连接。
总共有 m 个编号为 0 到 m - 1 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 重复 出现，但同一个城市在一条路径中不会连续出现。
给你一个整数 n 和二维数组 paths ，其中 paths[i] 是一个整数数组，表示第 i 个朋友走过的路径，请你返回 每一个 朋友都走过的 最长公共子路径 的长度，如果不存在公共子路径，请你返回 0 。
一个 子路径 指的是一条路径中连续的城市序列。
fn sa_is(s: &amp;[usize], upper: usize) -&gt; Vec&lt;usize&gt; { let n = s.len(); match n { 0 =&gt; return vec![], 1 =&gt; return vec![0], 2 =&gt; return if s[0] &lt; s[1] { vec!
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%844/" class="link black dim">
        Leetcode 后缀数组4
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      最长重复子串 给你一个字符串 s ，考虑其所有 重复子串 ：即 s 的（连续）子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。
返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 &quot;&quot; 。
impl Solution { // tp已经排好，开始排序第一关键字 fn sort(sa: &amp;mut Vec&lt;usize&gt;, rank: &amp;mut Vec&lt;usize&gt;, tp: &amp;Vec&lt;usize&gt;, n: usize, m: usize) { let mut tax = vec![0; m+1]; // 第一关键字基数排序 rank[1..].iter().for_each(|x| tax[*x] += 1); // 前缀和，为了后面方便计算第几名 for i in 1..=m { tax[i] += tax[i-1]; } tp[1..].iter().rev().for_each(|&amp;key| { // 拿最小的第二关键字对应的后缀key_2，然后通过rank找到他对应的第一关键字所处的level(第一关键字排名) let level = rank[key]; // tax[level]就表示在这里level之下一共有j个数，则后缀(tp[i])排名第j // 此时放的是第一关键字相同，第二关键字最大 // rank其实也是排好的，拿的是前w/2的rank let j = tax[level]; sa[j] = key; tax[level] -= 1; }); } fn init(s: &amp;str, n: usize, m: usize) -&gt; (Vec&lt;usize&gt;, Vec&lt;usize&gt;, Vec&lt;usize&gt;) { // 只有第一关键字直接映射就好 let mut rank = vec!
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E6%A1%B6%E6%8E%92%E5%BA%8F1/" class="link black dim">
        Leetcode 桶排序1
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      存在重复元素 III 给你一个整数数组 nums 和两个整数 indexDiff 和 valueDiff 。
找出满足下述条件的下标对 (i, j)：
i != j, abs(i - j) &lt;= indexDiff abs(nums[i] - nums[j]) &lt;= valueDiff 如果存在，返回 true ；否则，返回 false 。
impl Solution { pub fn contains_nearby_almost_duplicate( nums: Vec&lt;i32&gt;, index_diff: i32, value_diff: i32, ) -&gt; bool { // NOTE 桶排序的好题，通过将数字划分为若干个区间，来判断是否滑动窗口内是否存在value_diff范围内的数字对 // 桶的大小为value_diff，作为整除的除数因此加一 let value_diff = value_diff as i64 + 1; let mut num_bucket = std::collections::HashMap::new(); for (i, &amp;num) in nums.iter().enumerate() { let key = Self::get_id(num, value_diff); if num_bucket.
    </div>
  </div>
</div>

        </div>
      
    </section>
    <ul class="pagination pagination-default">
      <li class="page-item">
        <a href="/posts/" aria-label="First" class="page-link" role="button"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/" aria-label="Previous" class="page-link" role="button"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/" aria-label="Page 1" class="page-link" role="button">1</a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 2" class="page-link" role="button">2</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/3/" aria-label="Page 3" class="page-link" role="button">3</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/4/" aria-label="Page 4" class="page-link" role="button">4</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/5/" aria-label="Page 5" class="page-link" role="button">5</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/3/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/11/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  Paperubit的博客 2023 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
