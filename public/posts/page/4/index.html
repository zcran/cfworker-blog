<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Paperubit的博客</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.113.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
      <link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="Paperubit的博客" />
      <link href="/posts/index.xml" rel="feed" type="application/rss+xml" title="Paperubit的博客" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://example.org/posts/" />
<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Paperubit的博客
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E6%89%AB%E6%8F%8F%E7%BA%BF3/" class="link black dim">
        Leetcode 扫描线3
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      天际线问题 城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。
每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：
left⌄i 是第 i 座建筑物左边缘的 x 坐标。 right⌄i 是第 i 座建筑物右边缘的 x 坐标。 height⌄i 是第 i 座建筑物的高度。 你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。
天际线 应该表示为由 “关键点” 组成的列表，格式 [[x⌄1,y⌄1],[x⌄2,y⌄2],&hellip;] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。
注意：输出天际线中不得有连续的相同高度的水平线。例如 [&hellip;[2 3], [4 5], [7 5], [11 5], [12 7]&hellip;] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[&hellip;[2 3], [4 5], [12 7], &hellip;]
impl Solution { pub fn get_skyline(buildings: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; { let mut boundaries:Vec&lt;i32&gt; = buildings.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E6%89%AB%E6%8F%8F%E7%BA%BF4/" class="link black dim">
        Leetcode 扫描线4
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      完美矩形 给你一个数组 rectangles ，其中 rectangles[i] = [x⌄i, y⌄i, a⌄i, b⌄i] 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 (x⌄i, y⌄i) ，右上顶点是 (a⌄i, b⌄i) 。
如果所有矩形一起精确覆盖了某个矩形区域，则返回 true ；否则，返回 false 。
// 格林公式 use std::collections::HashSet; impl Solution { pub fn is_rectangle_cover(rectangles: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; bool { let (x1, y1, x2, y2, a, s) = rectangles .iter() .fold((i32::MAX, i32::MAX, i32::MIN, i32::MIN, 0, HashSet::new()), |(x1, y1, x2, y2, a, mut s), rect| { for p in [(rect[0], rect[1]), (rect[2], rect[1]), (rect[0], rect[3]), (rect[2], rect[3])] { if !
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-shell1/" class="link black dim">
        Leetcode Shell1
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      第十行 给定一个文本文件 file.txt，请只打印这个文件中的第十行。
sed -n &#39;10p&#39; file.txt 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-shell2/" class="link black dim">
        Leetcode Shell2
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      统计词频 写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。
为了简单起见，你可以假设：
words.txt只包括小写字母和 &rsquo; &rsquo; 。 每个单词只由小写字母组成。 单词间由一个或多个空格字符分隔。 示例:
假设 words.txt 内容如下：
the day is sunny the the the sunny is is 你的脚本应当输出（以词频降序排列）：
the 4 is 3 sunny 2 day 1 说明:
不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。 你可以使用一行 Unix pipes 实现吗？
cat words.txt | tr -s &#39; &#39; &#39;\n&#39;|sort|uniq -c |sort -r|awk &#39;{print $2&#34; &#34;$1}&#39; cat ——浏览文件 tr -s ——替换字符串（空格换为换行）保证了一行一个单词 sort ——默认ASCII值排序，排序号后还会有重复 uniq —— 去重，-c再输出重复次数。结果就是 ”4 abc“ abc出现了4次 sort -r —— 反向排序，也就是从大到小。得到按频率高低的结果 awk ——格式化输出，规定输出是先字符串再重复次数，所以先$2再$1，中间空格分隔 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-shell3/" class="link black dim">
        Leetcode Shell3
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      有效电话号码 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。
你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）
你也可以假设每行前后没有多余的空格字符。
// 三种方法 grep -P &#39;^(\d{3}-|\(\d{3}\) )\d{3}-\d{4}$&#39; file.txt sed -n -r &#39;/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/p&#39; file.txt awk &#39;/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-([0-9]{4})$/&#39; file.txt 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-shell4/" class="link black dim">
        Leetcode Shell4
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转置文件 给定一个文件 file.txt，转置它的内容。
你可以假设每行列数相同，并且每个字段由 &rsquo; &rsquo; 分隔。
# Read from the file file.txt and print its transposed content to stdout. awk &#39;{ #这个大括号里的代码是 对正文的处理 # NF表示列数，NR表示已读的行数 # 注意for中的i从1开始，i前没有类型 for (i=1; i&lt;=NF; i++){#对每一列 if(NR==1){ #如果是第一行 #将第i列的值存入res[i],$i表示第i列的值，i为数组的下标，以列序号为下标， #数组不用定义可以直接使用 res[i]=$i; } else{ #不是第一行时，将该行对应i列的值拼接到res[i] res[i]=res[i] &#34; &#34; $i } } } # BEGIN{} 文件进行扫描前要执行的操作；END{} 文件扫描结束后要执行的操作。 END{ #输出数组 for (i=1; i&lt;=NF; i++){ print res[i] } }&#39; file.txt 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B71/" class="link black dim">
        Leetcode 水塘抽样1
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      非重叠矩形中的随机点 给定一个由非重叠的轴对齐矩形的数组 rects ，其中 rects[i] = [ai, bi, xi, yi] 表示 (ai, bi) 是第 i 个矩形的左下角点，(xi, yi) 是第 i 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。
在给定的矩形覆盖的空间内的任何整数点都有可能被返回。
请注意 ，整数点是具有整数坐标的点。
实现 Solution 类:
Solution(int[][] rects) 用给定的矩形数组 rects 初始化对象。 int[] pick() 返回一个随机的整数点 [u, v] 在给定的矩形所覆盖的空间内。
use rand::{thread_rng, Rng}; struct Solution { rects: Vec&lt;Vec&lt;i32&gt;&gt;, arr: Vec&lt;i32&gt;, } impl Solution { fn new(rects: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Self { let arr = rects .iter() .scan(0, |v, rect| { *v += (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1); Some(*v) }) .
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B72/" class="link black dim">
        Leetcode 水塘抽样2
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      链表随机节点 给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。
实现 Solution 类：
Solution(ListNode head) 使用整数数组初始化对象。 int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。
struct Solution { list: Vec&lt;i32&gt;, } impl Solution { fn new(mut head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Self { let mut list = Vec::new(); while let Some(mut node) = head { list.push(node.val); head = node.next.take(); } Self { list } } fn get_random(&amp;self) -&gt; i32 { use rand::{Rng, thread_rng}; self.list[thread_rng().gen_range(0, self.list.len())] } } 
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B73/" class="link black dim">
        Leetcode 水塘抽样3
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      随机翻转矩阵 给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。
尽量最少调用内置的随机函数，并且优化时间和空间复杂度。
实现 Solution 类：
Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象 int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1 void reset() 将矩阵中所有的值重置为 0
use rand::prelude::*; use std::collections::HashMap; struct Solution { n: usize, idx: HashMap&lt;usize, usize&gt;, rng: ThreadRng, r: usize, c: usize, } impl Solution { fn new(m: i32, n: i32) -&gt; Self { Solution { n: m as usize * n as usize, idx: HashMap::new(), rng: thread_rng(), r: m as usize, c: n as usize, } } fn flip(&amp;mut self) -&gt; Vec&lt;i32&gt; { let v = self.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/posts/leetcode-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B74/" class="link black dim">
        Leetcode 水塘抽样4
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      随机数索引 给你一个可能含有 重复元素 的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组中。
实现 Solution 类：
Solution(int[] nums) 用数组 nums 初始化对象。 int pick(int target) 从 nums 中选出一个满足 nums[i] == target 的随机索引 i 。如果存在多个有效的索引，则每个索引的返回概率应当相等。
use rand::{rngs::ThreadRng, Rng}; use std::collections::HashMap; struct Solution { map: HashMap&lt;i32, Vec&lt;usize&gt;&gt;, rand: ThreadRng, } impl Solution { fn new(nums: Vec&lt;i32&gt;) -&gt; Self { Solution { map: nums .iter() .enumerate() .fold(HashMap::new(), |mut m, (i, &amp;n)| { m.entry(n).and_modify(|v| v.push(i)).or_insert(vec![i]); m }), rand: rand::thread_rng(), } } fn pick(&amp;mut self, target: i32) -&gt; i32 { let v = self.
    </div>
  </div>
</div>

        </div>
      
    </section>
    <ul class="pagination pagination-default">
      <li class="page-item">
        <a href="/posts/" aria-label="First" class="page-link" role="button"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/3/" aria-label="Previous" class="page-link" role="button"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/2/" aria-label="Page 2" class="page-link" role="button">2</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/3/" aria-label="Page 3" class="page-link" role="button">3</a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 4" class="page-link" role="button">4</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/5/" aria-label="Page 5" class="page-link" role="button">5</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/6/" aria-label="Page 6" class="page-link" role="button">6</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/5/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/11/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  Paperubit的博客 2023 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
